// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: dbRoot_v2.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Definition of all protocol buffers used by dbroot v2 protocol.
// The goal is to convert all dbroot-related tools (in VPE and mappacket) to
// use this protocol definition and deprecate
//
// NOTE: Currently, py api versioning is not suppored in the open source
// protocol buffer library, so inserting one in this proto will break the
// Google Earth client builds.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Protocol message that pairs an ID (which must be unique in the entire dbroot
/// hierarchy downloaded in one session) with an actual string.
struct Keyhole_Dbroot_StringEntryProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of string used in other parts of dbroot. Always use 4 bytes
  /// for storage to avoid ints taking way more space than this, since we will
  /// use large numbers frequently.
  var stringID: UInt32 {
    get {return _stringID ?? 0}
    set {_stringID = newValue}
  }
  /// Returns true if `stringID` has been explicitly set.
  var hasStringID: Bool {return self._stringID != nil}
  /// Clears the value of `stringID`. Subsequent reads from it will return its default value.
  mutating func clearStringID() {self._stringID = nil}

  /// Actual value of string
  var stringValue: String {
    get {return _stringValue ?? String()}
    set {_stringValue = newValue}
  }
  /// Returns true if `stringValue` has been explicitly set.
  var hasStringValue: Bool {return self._stringValue != nil}
  /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
  mutating func clearStringValue() {self._stringValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stringID: UInt32? = nil
  fileprivate var _stringValue: String? = nil
}

/// Simple pair that can contain either a string id (which must be unique across
/// all ids in the dbroot hierarchy) or an actual value. If both values are
/// present, behavior of the client is undefined and implementation dependent.
/// Nearly all string values in other protocol messages use this message to
/// allow strings to be specified as an index in the translation table, or
/// directly (which eliminates the need for any lookup)
/// Strings that must be translated (e.g. not the same across all languages)
/// should probably use the string_id field so that the translation (which
/// varies) can be put in the translation table portion of the dbroot
/// (see DbRootProto below). This allows the part that references string_id
/// to be the same across all language versions of dbroot, and have only one
/// dbroot object that changes across different languages.
struct Keyhole_Dbroot_StringIdOrValueProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id of string to look up in translation table (see DbRootProto)
  var stringID: UInt32 {
    get {return _stringID ?? 0}
    set {_stringID = newValue}
  }
  /// Returns true if `stringID` has been explicitly set.
  var hasStringID: Bool {return self._stringID != nil}
  /// Clears the value of `stringID`. Subsequent reads from it will return its default value.
  mutating func clearStringID() {self._stringID = nil}

  /// Actual value of string, if present - does not require any lookup.
  var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stringID: UInt32? = nil
  fileprivate var _value: String? = nil
}

/// List of values that describe the planet size and shape (assumed to be an
/// oblate spheroid) and extra data that allow encoding negative altitudes under
/// the water surface
struct Keyhole_Dbroot_PlanetModelProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mean planet radius. Default value is the WGS84 model for earth.
  var radius: Double {
    get {return _radius ?? 6378.137}
    set {_radius = newValue}
  }
  /// Returns true if `radius` has been explicitly set.
  var hasRadius: Bool {return self._radius != nil}
  /// Clears the value of `radius`. Subsequent reads from it will return its default value.
  mutating func clearRadius() {self._radius = nil}

  /// Planet flattening. Default value is 1.0/298.257223563 (from  WGS84)
  var flattening: Double {
    get {return _flattening ?? 0.00335281066474748}
    set {_flattening = newValue}
  }
  /// Returns true if `flattening` has been explicitly set.
  var hasFlattening: Bool {return self._flattening != nil}
  /// Clears the value of `flattening`. Subsequent reads from it will return its default value.
  mutating func clearFlattening() {self._flattening = nil}

  /// Elevation bias
  var elevationBias: Double {
    get {return _elevationBias ?? 0}
    set {_elevationBias = newValue}
  }
  /// Returns true if `elevationBias` has been explicitly set.
  var hasElevationBias: Bool {return self._elevationBias != nil}
  /// Clears the value of `elevationBias`. Subsequent reads from it will return its default value.
  mutating func clearElevationBias() {self._elevationBias = nil}

  /// Bias for negative altitude so that ocean tiles can be streamed to older
  /// clients
  var negativeAltitudeExponentBias: Int32 {
    get {return _negativeAltitudeExponentBias ?? 0}
    set {_negativeAltitudeExponentBias = newValue}
  }
  /// Returns true if `negativeAltitudeExponentBias` has been explicitly set.
  var hasNegativeAltitudeExponentBias: Bool {return self._negativeAltitudeExponentBias != nil}
  /// Clears the value of `negativeAltitudeExponentBias`. Subsequent reads from it will return its default value.
  mutating func clearNegativeAltitudeExponentBias() {self._negativeAltitudeExponentBias = nil}

  /// Threshold below which negative altitudes are compressed
  var compressedNegativeAltitudeThreshold: Double {
    get {return _compressedNegativeAltitudeThreshold ?? 0}
    set {_compressedNegativeAltitudeThreshold = newValue}
  }
  /// Returns true if `compressedNegativeAltitudeThreshold` has been explicitly set.
  var hasCompressedNegativeAltitudeThreshold: Bool {return self._compressedNegativeAltitudeThreshold != nil}
  /// Clears the value of `compressedNegativeAltitudeThreshold`. Subsequent reads from it will return its default value.
  mutating func clearCompressedNegativeAltitudeThreshold() {self._compressedNegativeAltitudeThreshold = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _radius: Double? = nil
  fileprivate var _flattening: Double? = nil
  fileprivate var _elevationBias: Double? = nil
  fileprivate var _negativeAltitudeExponentBias: Int32? = nil
  fileprivate var _compressedNegativeAltitudeThreshold: Double? = nil
}

/// The client has the ability to display a copyright message on a per-layer
/// basis only. If you have multiple providers' data contained in one layer and
/// need to display a copyright for each, you'll have to break the layer into
/// multiples, each with its own provider specified.
struct Keyhole_Dbroot_ProviderInfoProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Must be unique across all providers.
  var providerID: Int32 {
    get {return _providerID ?? 0}
    set {_providerID = newValue}
  }
  /// Returns true if `providerID` has been explicitly set.
  var hasProviderID: Bool {return self._providerID != nil}
  /// Clears the value of `providerID`. Subsequent reads from it will return its default value.
  mutating func clearProviderID() {self._providerID = nil}

  /// Contents of the copyright as an actual string or index in translation
  /// table.
  var copyrightString: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _copyrightString ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_copyrightString = newValue}
  }
  /// Returns true if `copyrightString` has been explicitly set.
  var hasCopyrightString: Bool {return self._copyrightString != nil}
  /// Clears the value of `copyrightString`. Subsequent reads from it will return its default value.
  mutating func clearCopyrightString() {self._copyrightString = nil}

  /// Distance in pixels that indicates how far from the bottom of the screen
  /// the copyright appears for that provider.
  var verticalPixelOffset: Int32 {
    get {return _verticalPixelOffset ?? -1}
    set {_verticalPixelOffset = newValue}
  }
  /// Returns true if `verticalPixelOffset` has been explicitly set.
  var hasVerticalPixelOffset: Bool {return self._verticalPixelOffset != nil}
  /// Clears the value of `verticalPixelOffset`. Subsequent reads from it will return its default value.
  mutating func clearVerticalPixelOffset() {self._verticalPixelOffset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _providerID: Int32? = nil
  fileprivate var _copyrightString: Keyhole_Dbroot_StringIdOrValueProto? = nil
  fileprivate var _verticalPixelOffset: Int32? = nil
}

/// When a placemark is clicked on a pop-up bubble 'pops up'. Only enabled for
/// point layers, the pop-up bubbles support a very limited set of HTML and
/// image linking. For a full description of what can be contained in the
/// pop-up bubble description go to:
/// http://earth.google.com/kml/kml_tags_21.html#description
struct Keyhole_Dbroot_PopUpProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Over-rides the default client pop-up html which contains entity references
  /// to $[name] and $[geDirections]. Set this field to true if you want
  /// to control all of the HTML behavior in the bubble.
  var isBalloonStyle: Bool {
    get {return _isBalloonStyle ?? false}
    set {_isBalloonStyle = newValue}
  }
  /// Returns true if `isBalloonStyle` has been explicitly set.
  var hasIsBalloonStyle: Bool {return self._isBalloonStyle != nil}
  /// Clears the value of `isBalloonStyle`. Subsequent reads from it will return its default value.
  mutating func clearIsBalloonStyle() {self._isBalloonStyle = nil}

  /// Text contents of description or balloon style.
  var text: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _text ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  /// Background and text color in balloon. Both colors must be specified
  /// in abgr format.
  var backgroundColorAbgr: UInt32 {
    get {return _backgroundColorAbgr ?? 4294967295}
    set {_backgroundColorAbgr = newValue}
  }
  /// Returns true if `backgroundColorAbgr` has been explicitly set.
  var hasBackgroundColorAbgr: Bool {return self._backgroundColorAbgr != nil}
  /// Clears the value of `backgroundColorAbgr`. Subsequent reads from it will return its default value.
  mutating func clearBackgroundColorAbgr() {self._backgroundColorAbgr = nil}

  var textColorAbgr: UInt32 {
    get {return _textColorAbgr ?? 4278190080}
    set {_textColorAbgr = newValue}
  }
  /// Returns true if `textColorAbgr` has been explicitly set.
  var hasTextColorAbgr: Bool {return self._textColorAbgr != nil}
  /// Clears the value of `textColorAbgr`. Subsequent reads from it will return its default value.
  mutating func clearTextColorAbgr() {self._textColorAbgr = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _isBalloonStyle: Bool? = nil
  fileprivate var _text: Keyhole_Dbroot_StringIdOrValueProto? = nil
  fileprivate var _backgroundColorAbgr: UInt32? = nil
  fileprivate var _textColorAbgr: UInt32? = nil
}

struct Keyhole_Dbroot_StyleAttributeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique id for this style attribute specification.
  var styleID: String {
    get {return _storage._styleID ?? String()}
    set {_uniqueStorage()._styleID = newValue}
  }
  /// Returns true if `styleID` has been explicitly set.
  var hasStyleID: Bool {return _storage._styleID != nil}
  /// Clears the value of `styleID`. Subsequent reads from it will return its default value.
  mutating func clearStyleID() {_uniqueStorage()._styleID = nil}

  /// The provider id used here must be present in the ProviderInfoProto if
  /// other than the default. If you need copyright strings to display make sure
  /// to fill this value.
  var providerID: Int32 {
    get {return _storage._providerID ?? 0}
    set {_uniqueStorage()._providerID = newValue}
  }
  /// Returns true if `providerID` has been explicitly set.
  var hasProviderID: Bool {return _storage._providerID != nil}
  /// Clears the value of `providerID`. Subsequent reads from it will return its default value.
  mutating func clearProviderID() {_uniqueStorage()._providerID = nil}

  /// Display color for polygons.
  var polyColorAbgr: UInt32 {
    get {return _storage._polyColorAbgr ?? 4294967295}
    set {_uniqueStorage()._polyColorAbgr = newValue}
  }
  /// Returns true if `polyColorAbgr` has been explicitly set.
  var hasPolyColorAbgr: Bool {return _storage._polyColorAbgr != nil}
  /// Clears the value of `polyColorAbgr`. Subsequent reads from it will return its default value.
  mutating func clearPolyColorAbgr() {_uniqueStorage()._polyColorAbgr = nil}

  /// Display color for lines.
  var lineColorAbgr: UInt32 {
    get {return _storage._lineColorAbgr ?? 4294967295}
    set {_uniqueStorage()._lineColorAbgr = newValue}
  }
  /// Returns true if `lineColorAbgr` has been explicitly set.
  var hasLineColorAbgr: Bool {return _storage._lineColorAbgr != nil}
  /// Clears the value of `lineColorAbgr`. Subsequent reads from it will return its default value.
  mutating func clearLineColorAbgr() {_uniqueStorage()._lineColorAbgr = nil}

  var lineWidth: Float {
    get {return _storage._lineWidth ?? 1}
    set {_uniqueStorage()._lineWidth = newValue}
  }
  /// Returns true if `lineWidth` has been explicitly set.
  var hasLineWidth: Bool {return _storage._lineWidth != nil}
  /// Clears the value of `lineWidth`. Subsequent reads from it will return its default value.
  mutating func clearLineWidth() {_uniqueStorage()._lineWidth = nil}

  /// Display color of placemark or road name text.
  var labelColorAbgr: UInt32 {
    get {return _storage._labelColorAbgr ?? 4294967295}
    set {_uniqueStorage()._labelColorAbgr = newValue}
  }
  /// Returns true if `labelColorAbgr` has been explicitly set.
  var hasLabelColorAbgr: Bool {return _storage._labelColorAbgr != nil}
  /// Clears the value of `labelColorAbgr`. Subsequent reads from it will return its default value.
  mutating func clearLabelColorAbgr() {_uniqueStorage()._labelColorAbgr = nil}

  var labelScale: Float {
    get {return _storage._labelScale ?? 1}
    set {_uniqueStorage()._labelScale = newValue}
  }
  /// Returns true if `labelScale` has been explicitly set.
  var hasLabelScale: Bool {return _storage._labelScale != nil}
  /// Clears the value of `labelScale`. Subsequent reads from it will return its default value.
  mutating func clearLabelScale() {_uniqueStorage()._labelScale = nil}

  /// Controls icon 'tinting', a color hue will be applied to the con if
  /// specified here.
  var placemarkIconColorAbgr: UInt32 {
    get {return _storage._placemarkIconColorAbgr ?? 4294967295}
    set {_uniqueStorage()._placemarkIconColorAbgr = newValue}
  }
  /// Returns true if `placemarkIconColorAbgr` has been explicitly set.
  var hasPlacemarkIconColorAbgr: Bool {return _storage._placemarkIconColorAbgr != nil}
  /// Clears the value of `placemarkIconColorAbgr`. Subsequent reads from it will return its default value.
  mutating func clearPlacemarkIconColorAbgr() {_uniqueStorage()._placemarkIconColorAbgr = nil}

  var placemarkIconScale: Float {
    get {return _storage._placemarkIconScale ?? 1}
    set {_uniqueStorage()._placemarkIconScale = newValue}
  }
  /// Returns true if `placemarkIconScale` has been explicitly set.
  var hasPlacemarkIconScale: Bool {return _storage._placemarkIconScale != nil}
  /// Clears the value of `placemarkIconScale`. Subsequent reads from it will return its default value.
  mutating func clearPlacemarkIconScale() {_uniqueStorage()._placemarkIconScale = nil}

  /// Path to the icon that will be displayed for placemarks or road shields.
  /// These can be either 32x32 or 64x64 8-bit/color RGBA, non-interlaced png
  /// images. Path can be translated through translation table mechanism (see
  /// definition of StringIdOrValueProto for more info).
  var placemarkIconPath: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._placemarkIconPath ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._placemarkIconPath = newValue}
  }
  /// Returns true if `placemarkIconPath` has been explicitly set.
  var hasPlacemarkIconPath: Bool {return _storage._placemarkIconPath != nil}
  /// Clears the value of `placemarkIconPath`. Subsequent reads from it will return its default value.
  mutating func clearPlacemarkIconPath() {_uniqueStorage()._placemarkIconPath = nil}

  /// Specify the offset you'd like from the placemark coordinate point on the X
  /// axis.
  var placemarkIconX: Int32 {
    get {return _storage._placemarkIconX ?? 0}
    set {_uniqueStorage()._placemarkIconX = newValue}
  }
  /// Returns true if `placemarkIconX` has been explicitly set.
  var hasPlacemarkIconX: Bool {return _storage._placemarkIconX != nil}
  /// Clears the value of `placemarkIconX`. Subsequent reads from it will return its default value.
  mutating func clearPlacemarkIconX() {_uniqueStorage()._placemarkIconX = nil}

  /// Specify the offset you'd like from the placemark coordinate point on the Y
  /// axis.
  var placemarkIconY: Int32 {
    get {return _storage._placemarkIconY ?? 0}
    set {_uniqueStorage()._placemarkIconY = newValue}
  }
  /// Returns true if `placemarkIconY` has been explicitly set.
  var hasPlacemarkIconY: Bool {return _storage._placemarkIconY != nil}
  /// Clears the value of `placemarkIconY`. Subsequent reads from it will return its default value.
  mutating func clearPlacemarkIconY() {_uniqueStorage()._placemarkIconY = nil}

  /// Usually, either 32 or 64.
  var placemarkIconWidth: Int32 {
    get {return _storage._placemarkIconWidth ?? 32}
    set {_uniqueStorage()._placemarkIconWidth = newValue}
  }
  /// Returns true if `placemarkIconWidth` has been explicitly set.
  var hasPlacemarkIconWidth: Bool {return _storage._placemarkIconWidth != nil}
  /// Clears the value of `placemarkIconWidth`. Subsequent reads from it will return its default value.
  mutating func clearPlacemarkIconWidth() {_uniqueStorage()._placemarkIconWidth = nil}

  /// Usually, either 32 or 64.
  var placemarkIconHeight: Int32 {
    get {return _storage._placemarkIconHeight ?? 32}
    set {_uniqueStorage()._placemarkIconHeight = newValue}
  }
  /// Returns true if `placemarkIconHeight` has been explicitly set.
  var hasPlacemarkIconHeight: Bool {return _storage._placemarkIconHeight != nil}
  /// Clears the value of `placemarkIconHeight`. Subsequent reads from it will return its default value.
  mutating func clearPlacemarkIconHeight() {_uniqueStorage()._placemarkIconHeight = nil}

  /// Fields to control behavior in the HTML pop up bubbles when placemarks
  /// are clicked on.
  var popUp: Keyhole_Dbroot_PopUpProto {
    get {return _storage._popUp ?? Keyhole_Dbroot_PopUpProto()}
    set {_uniqueStorage()._popUp = newValue}
  }
  /// Returns true if `popUp` has been explicitly set.
  var hasPopUp: Bool {return _storage._popUp != nil}
  /// Clears the value of `popUp`. Subsequent reads from it will return its default value.
  mutating func clearPopUp() {_uniqueStorage()._popUp = nil}

  /// List of draw flags that should be applied to this style. See definition
  /// of DrawFlagProto in dbroot.proto.
  var drawFlag: [Keyhole_Dbroot_DrawFlagProto] {
    get {return _storage._drawFlag}
    set {_uniqueStorage()._drawFlag = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Each fusion packet for layers has a mapping id number(s) baked into it that
/// reference the style map postamble in the dbroot. Each style map block
/// specifies pointers to two style attribute specifications that are used in
/// rendering the fusion packet. One for 'Normal' view (no mouse over) and
/// one for 'Highlight' view (mouse over). For non-point features, the normal
/// and highlight style maps point to the same style specification.
///
/// It is expected and even encouraged to use the same style attribute
/// specification ids across multiple style maps when they are exactly the same
/// as this helps shrink the size of the dbroot and improves parsing speed in
/// the client.
///
/// Example non-point layer: <etStyleMap> [20210] { "A"      "A" }
/// Meaning: Style map 20210 uses style spec "A" for normal and "A" for
///          highlight.
/// NOTE: For non-point layers only fill one style_attribute message as
/// normal. The writer will automatically fill in the style map for the
/// highlight style with the same style id as used for normal.
///
/// Example point layer: <etStyleMap> [20210] { "A"      "B" }
/// Meaning: Style map 20210 uses style spec "A" for normal and "B" for
///          highlight.
struct Keyhole_Dbroot_StyleMapProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var styleMapID: Int32 {
    get {return _styleMapID ?? 0}
    set {_styleMapID = newValue}
  }
  /// Returns true if `styleMapID` has been explicitly set.
  var hasStyleMapID: Bool {return self._styleMapID != nil}
  /// Clears the value of `styleMapID`. Subsequent reads from it will return its default value.
  mutating func clearStyleMapID() {self._styleMapID = nil}

  /// Specifies which layers this style map is referenced in.
  /// If not provided, one can always inspect all layers to find which ones
  /// reference this style map.
  var channelID: [Int32] = []

  /// Styles are associated with their corresponding layer.
  /// If provided, the value is an index into the array of styles.
  var normalStyleAttribute: Int32 {
    get {return _normalStyleAttribute ?? 0}
    set {_normalStyleAttribute = newValue}
  }
  /// Returns true if `normalStyleAttribute` has been explicitly set.
  var hasNormalStyleAttribute: Bool {return self._normalStyleAttribute != nil}
  /// Clears the value of `normalStyleAttribute`. Subsequent reads from it will return its default value.
  mutating func clearNormalStyleAttribute() {self._normalStyleAttribute = nil}

  var highlightStyleAttribute: Int32 {
    get {return _highlightStyleAttribute ?? 0}
    set {_highlightStyleAttribute = newValue}
  }
  /// Returns true if `highlightStyleAttribute` has been explicitly set.
  var hasHighlightStyleAttribute: Bool {return self._highlightStyleAttribute != nil}
  /// Clears the value of `highlightStyleAttribute`. Subsequent reads from it will return its default value.
  mutating func clearHighlightStyleAttribute() {self._highlightStyleAttribute = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _styleMapID: Int32? = nil
  fileprivate var _normalStyleAttribute: Int32? = nil
  fileprivate var _highlightStyleAttribute: Int32? = nil
}

/// Specifies a range of zoom levels that a style rule will be visible for.
struct Keyhole_Dbroot_ZoomRangeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minZoom: Int32 {
    get {return _minZoom ?? 0}
    set {_minZoom = newValue}
  }
  /// Returns true if `minZoom` has been explicitly set.
  var hasMinZoom: Bool {return self._minZoom != nil}
  /// Clears the value of `minZoom`. Subsequent reads from it will return its default value.
  mutating func clearMinZoom() {self._minZoom = nil}

  var maxZoom: Int32 {
    get {return _maxZoom ?? 0}
    set {_maxZoom = newValue}
  }
  /// Returns true if `maxZoom` has been explicitly set.
  var hasMaxZoom: Bool {return self._maxZoom != nil}
  /// Clears the value of `maxZoom`. Subsequent reads from it will return its default value.
  mutating func clearMaxZoom() {self._maxZoom = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _minZoom: Int32? = nil
  fileprivate var _maxZoom: Int32? = nil
}

/// Draw flags are used to control cartographic styling. For example, a polygon
/// layer with flag TYPE_FULL_ONLY would only display the outlines of the
/// polygon.
struct Keyhole_Dbroot_DrawFlagProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var drawFlagType: Keyhole_Dbroot_DrawFlagProto.DrawFlagType {
    get {return _drawFlagType ?? .typeFillOnly}
    set {_drawFlagType = newValue}
  }
  /// Returns true if `drawFlagType` has been explicitly set.
  var hasDrawFlagType: Bool {return self._drawFlagType != nil}
  /// Clears the value of `drawFlagType`. Subsequent reads from it will return its default value.
  mutating func clearDrawFlagType() {self._drawFlagType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DrawFlagType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case typeFillOnly // = 1
    case typeOutlineOnly // = 2
    case typeFillAndOutline // = 3
    case typeAntialiasing // = 4

    /// Points only.
    case typeCenterLabel // = 5

    init() {
      self = .typeFillOnly
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .typeFillOnly
      case 2: self = .typeOutlineOnly
      case 3: self = .typeFillAndOutline
      case 4: self = .typeAntialiasing
      case 5: self = .typeCenterLabel
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .typeFillOnly: return 1
      case .typeOutlineOnly: return 2
      case .typeFillAndOutline: return 3
      case .typeAntialiasing: return 4
      case .typeCenterLabel: return 5
      }
    }

  }

  init() {}

  fileprivate var _drawFlagType: Keyhole_Dbroot_DrawFlagProto.DrawFlagType? = nil
}

#if swift(>=4.2)

extension Keyhole_Dbroot_DrawFlagProto.DrawFlagType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Specific configurations for layers.
struct Keyhole_Dbroot_LayerProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the zoom range(s) that layer styles will be valid for.
  var zoomRange: [Keyhole_Dbroot_ZoomRangeProto] = []

  /// Controls the zoom level that text labels will be displayed until. For
  /// example with roads, it is common to have the line geometry fade out around
  /// 18-20 but have the label text continue until level 24.
  var preserveTextLevel: Int32 {
    get {return _preserveTextLevel ?? 30}
    set {_preserveTextLevel = newValue}
  }
  /// Returns true if `preserveTextLevel` has been explicitly set.
  var hasPreserveTextLevel: Bool {return self._preserveTextLevel != nil}
  /// Clears the value of `preserveTextLevel`. Subsequent reads from it will return its default value.
  mutating func clearPreserveTextLevel() {self._preserveTextLevel = nil}

  /// Controls how the client transitions between levels-of-detail (LOD) of this
  /// layer.  If lod_begin_transition is true, the client will fade in the layer
  /// when at the level that it is first displayed.  If lod_end_transition is
  /// true, the client will fade out the layer at the level that it is last
  /// displayed.
  var lodBeginTransition: Bool {
    get {return _lodBeginTransition ?? false}
    set {_lodBeginTransition = newValue}
  }
  /// Returns true if `lodBeginTransition` has been explicitly set.
  var hasLodBeginTransition: Bool {return self._lodBeginTransition != nil}
  /// Clears the value of `lodBeginTransition`. Subsequent reads from it will return its default value.
  mutating func clearLodBeginTransition() {self._lodBeginTransition = nil}

  var lodEndTransition: Bool {
    get {return _lodEndTransition ?? false}
    set {_lodEndTransition = newValue}
  }
  /// Returns true if `lodEndTransition` has been explicitly set.
  var hasLodEndTransition: Bool {return self._lodEndTransition != nil}
  /// Clears the value of `lodEndTransition`. Subsequent reads from it will return its default value.
  mutating func clearLodEndTransition() {self._lodEndTransition = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _preserveTextLevel: Int32? = nil
  fileprivate var _lodBeginTransition: Bool? = nil
  fileprivate var _lodEndTransition: Bool? = nil
}

/// Specific configuration options for folders.
struct Keyhole_Dbroot_FolderProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Controls whether the tree view of child folders or layers is visible.
  var isExpandable: Bool {
    get {return _isExpandable ?? true}
    set {_isExpandable = newValue}
  }
  /// Returns true if `isExpandable` has been explicitly set.
  var hasIsExpandable: Bool {return self._isExpandable != nil}
  /// Clears the value of `isExpandable`. Subsequent reads from it will return its default value.
  mutating func clearIsExpandable() {self._isExpandable = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _isExpandable: Bool? = nil
}

/// Requirements are configurations available for NestedFeatures that do not
/// exist in all client versions. They are all optional and provide additional
/// control over how and when layers are displayed.
struct Keyhole_Dbroot_RequirementProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Allows limiting display of a nested feature to computers with a specified
  /// vram threshold or above.
  /// Example: 64-127
  /// Meaning: Show iff 64 to 127MB of VRAM.
  /// Version support: 4.0.2292 +
  var requiredVram: String {
    get {return _requiredVram ?? String()}
    set {_requiredVram = newValue}
  }
  /// Returns true if `requiredVram` has been explicitly set.
  var hasRequiredVram: Bool {return self._requiredVram != nil}
  /// Clears the value of `requiredVram`. Subsequent reads from it will return its default value.
  mutating func clearRequiredVram() {self._requiredVram = nil}

  /// Allows limiting display of a nested feature to those with a client version
  /// at or above the value specified.
  /// Example: -4.0.2291
  /// Meaning: Exclude if 4.0.2292 or later.
  /// Version support: 4.0.2292 +
  var requiredClientVer: String {
    get {return _requiredClientVer ?? String()}
    set {_requiredClientVer = newValue}
  }
  /// Returns true if `requiredClientVer` has been explicitly set.
  var hasRequiredClientVer: Bool {return self._requiredClientVer != nil}
  /// Clears the value of `requiredClientVer`. Subsequent reads from it will return its default value.
  mutating func clearRequiredClientVer() {self._requiredClientVer = nil}

  /// Probability of being shown (preserved across sessions).
  /// Example: Layers: A with "-20" and B with "10-100"
  /// Meaning: 10% get A, 10% get A+B, 80% get B)
  /// Version support: 4.0.2292 +
  var probability: String {
    get {return _probability ?? String()}
    set {_probability = newValue}
  }
  /// Returns true if `probability` has been explicitly set.
  var hasProbability: Bool {return self._probability != nil}
  /// Clears the value of `probability`. Subsequent reads from it will return its default value.
  mutating func clearProbability() {self._probability = nil}

  /// Limit by anything in user agent.
  /// Example: (Windows|Mac)
  /// Meaning: PC & Mac but not Linux Excluded if RegExp is non-empty and match
  ///          fails.
  /// Version support: 4.0.2292 +
  var requiredUserAgent: String {
    get {return _requiredUserAgent ?? String()}
    set {_requiredUserAgent = newValue}
  }
  /// Returns true if `requiredUserAgent` has been explicitly set.
  var hasRequiredUserAgent: Bool {return self._requiredUserAgent != nil}
  /// Clears the value of `requiredUserAgent`. Subsequent reads from it will return its default value.
  mutating func clearRequiredUserAgent() {self._requiredUserAgent = nil}

  /// Limit by client capability
  /// TODO: update the example.
  /// Example: Not used in production yet, but something like 'supports Flash'.
  /// Version support: 4.3 +.
  var requiredClientCapabilities: String {
    get {return _requiredClientCapabilities ?? String()}
    set {_requiredClientCapabilities = newValue}
  }
  /// Returns true if `requiredClientCapabilities` has been explicitly set.
  var hasRequiredClientCapabilities: Bool {return self._requiredClientCapabilities != nil}
  /// Clears the value of `requiredClientCapabilities`. Subsequent reads from it will return its default value.
  mutating func clearRequiredClientCapabilities() {self._requiredClientCapabilities = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _requiredVram: String? = nil
  fileprivate var _requiredClientVer: String? = nil
  fileprivate var _probability: String? = nil
  fileprivate var _requiredUserAgent: String? = nil
  fileprivate var _requiredClientCapabilities: String? = nil
}

/// Message that defines a view (i.e. position and orientation of camera) of
/// the planet.
/// For more detailed documentation see:
/// http://code.google.com/apis/kml/documentation/kml_tags_21.html#lookat
/// NOTE: This does not support tags for altitudeMode or altitude.
struct Keyhole_Dbroot_LookAtProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var longitude: Float {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var latitude: Float {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var range: Float {
    get {return _range ?? 0}
    set {_range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  var hasRange: Bool {return self._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  mutating func clearRange() {self._range = nil}

  var tilt: Float {
    get {return _tilt ?? 0}
    set {_tilt = newValue}
  }
  /// Returns true if `tilt` has been explicitly set.
  var hasTilt: Bool {return self._tilt != nil}
  /// Clears the value of `tilt`. Subsequent reads from it will return its default value.
  mutating func clearTilt() {self._tilt = nil}

  var heading: Float {
    get {return _heading ?? 0}
    set {_heading = newValue}
  }
  /// Returns true if `heading` has been explicitly set.
  var hasHeading: Bool {return self._heading != nil}
  /// Clears the value of `heading`. Subsequent reads from it will return its default value.
  mutating func clearHeading() {self._heading = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _longitude: Float? = nil
  fileprivate var _latitude: Float? = nil
  fileprivate var _range: Float? = nil
  fileprivate var _tilt: Float? = nil
  fileprivate var _heading: Float? = nil
}

/// A nested feature is an entity in the layer menu tree. The feature may
/// be either a folder (think container for more child features) or a layer
/// (a layer is a vector data layer that displays points, lines, or polygons).
/// Next available id: 22
struct Keyhole_Dbroot_NestedFeatureProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var featureType: Keyhole_Dbroot_NestedFeatureProto.FeatureType {
    get {return _storage._featureType ?? .typePointZ}
    set {_uniqueStorage()._featureType = newValue}
  }
  /// Returns true if `featureType` has been explicitly set.
  var hasFeatureType: Bool {return _storage._featureType != nil}
  /// Clears the value of `featureType`. Subsequent reads from it will return its default value.
  mutating func clearFeatureType() {_uniqueStorage()._featureType = nil}

  /// URL of KML layer, if present.
  /// Version support: GE 4.0.2292+, GE5
  var kmlURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._kmlURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._kmlURL = newValue}
  }
  /// Returns true if `kmlURL` has been explicitly set.
  var hasKmlURL: Bool {return _storage._kmlURL != nil}
  /// Clears the value of `kmlURL`. Subsequent reads from it will return its default value.
  mutating func clearKmlURL() {_uniqueStorage()._kmlURL = nil}

  /// If this url appears, it means this object is referring to a secondary
  /// database that should be added.
  var databaseURL: String {
    get {return _storage._databaseURL ?? String()}
    set {_uniqueStorage()._databaseURL = newValue}
  }
  /// Returns true if `databaseURL` has been explicitly set.
  var hasDatabaseURL: Bool {return _storage._databaseURL != nil}
  /// Clears the value of `databaseURL`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseURL() {_uniqueStorage()._databaseURL = nil}

  /// Data members only used for layers.
  var layer: Keyhole_Dbroot_LayerProto {
    get {return _storage._layer ?? Keyhole_Dbroot_LayerProto()}
    set {_uniqueStorage()._layer = newValue}
  }
  /// Returns true if `layer` has been explicitly set.
  var hasLayer: Bool {return _storage._layer != nil}
  /// Clears the value of `layer`. Subsequent reads from it will return its default value.
  mutating func clearLayer() {_uniqueStorage()._layer = nil}

  /// Data members only used in containers of other features. This has no effect
  /// if the layer has no children.
  var folder: Keyhole_Dbroot_FolderProto {
    get {return _storage._folder ?? Keyhole_Dbroot_FolderProto()}
    set {_uniqueStorage()._folder = newValue}
  }
  /// Returns true if `folder` has been explicitly set.
  var hasFolder: Bool {return _storage._folder != nil}
  /// Clears the value of `folder`. Subsequent reads from it will return its default value.
  mutating func clearFolder() {_uniqueStorage()._folder = nil}

  /// Additional, optional specifications to extend layers and folders.
  var requirement: Keyhole_Dbroot_RequirementProto {
    get {return _storage._requirement ?? Keyhole_Dbroot_RequirementProto()}
    set {_uniqueStorage()._requirement = newValue}
  }
  /// Returns true if `requirement` has been explicitly set.
  var hasRequirement: Bool {return _storage._requirement != nil}
  /// Clears the value of `requirement`. Subsequent reads from it will return its default value.
  mutating func clearRequirement() {_uniqueStorage()._requirement = nil}

  /// Each nested feature must have its own unique identifier number. This
  /// identifier is used in several places in the quadtree packets and fusion
  /// packets to link the fusion packet to a given style specification for
  /// example.
  var channelID: Int32 {
    get {return _storage._channelID ?? 0}
    set {_uniqueStorage()._channelID = newValue}
  }
  /// Returns true if `channelID` has been explicitly set.
  var hasChannelID: Bool {return _storage._channelID != nil}
  /// Clears the value of `channelID`. Subsequent reads from it will return its default value.
  mutating func clearChannelID() {_uniqueStorage()._channelID = nil}

  /// Name of the nested feature, either as a string ID or actual value.
  /// Names that must be translated should probably use string IDs so this
  /// part of the protocol buffer is the same across all languages.
  var displayName: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._displayName ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._displayName = newValue}
  }
  /// Returns true if `displayName` has been explicitly set.
  var hasDisplayName: Bool {return _storage._displayName != nil}
  /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
  mutating func clearDisplayName() {_uniqueStorage()._displayName = nil}

  /// Controls whether the nested feature can be seen or not in the layer panel
  /// menu. Visibility is inherited from parents too (all parents in the
  /// hierarchy must be visible for a layer to be visible).
  var isVisible: Bool {
    get {return _storage._isVisible ?? true}
    set {_uniqueStorage()._isVisible = newValue}
  }
  /// Returns true if `isVisible` has been explicitly set.
  var hasIsVisible: Bool {return _storage._isVisible != nil}
  /// Clears the value of `isVisible`. Subsequent reads from it will return its default value.
  mutating func clearIsVisible() {_uniqueStorage()._isVisible = nil}

  /// Controls whether the nested feature is turned on by default when the
  /// client starts up.
  var isEnabled: Bool {
    get {return _storage._isEnabled ?? true}
    set {_uniqueStorage()._isEnabled = newValue}
  }
  /// Returns true if `isEnabled` has been explicitly set.
  var hasIsEnabled: Bool {return _storage._isEnabled != nil}
  /// Clears the value of `isEnabled`. Subsequent reads from it will return its default value.
  mutating func clearIsEnabled() {_uniqueStorage()._isEnabled = nil}

  /// Does the feature have a 'check' in the layer menu panel.
  var isChecked: Bool {
    get {return _storage._isChecked ?? false}
    set {_uniqueStorage()._isChecked = newValue}
  }
  /// Returns true if `isChecked` has been explicitly set.
  var hasIsChecked: Bool {return _storage._isChecked != nil}
  /// Clears the value of `isChecked`. Subsequent reads from it will return its default value.
  mutating func clearIsChecked() {_uniqueStorage()._isChecked = nil}

  /// Path of image that will be displayed in the layer menu panel. These must
  /// be 16x16 8-bit/color RGBA, non-interlaced png images.
  var layerMenuIconPath: String {
    get {return _storage._layerMenuIconPath ?? "icons/773_l.png"}
    set {_uniqueStorage()._layerMenuIconPath = newValue}
  }
  /// Returns true if `layerMenuIconPath` has been explicitly set.
  var hasLayerMenuIconPath: Bool {return _storage._layerMenuIconPath != nil}
  /// Clears the value of `layerMenuIconPath`. Subsequent reads from it will return its default value.
  mutating func clearLayerMenuIconPath() {_uniqueStorage()._layerMenuIconPath = nil}

  /// Human readable description string of the layer.
  var description_p: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._description_p ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return _storage._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {_uniqueStorage()._description_p = nil}

  /// Default view for that layer. In Google Earth, double-clicking on that layer
  /// flies to the default view of the layer if it is specified. Layers with no
  /// default view cannot be "flown to".
  var lookAt: Keyhole_Dbroot_LookAtProto {
    get {return _storage._lookAt ?? Keyhole_Dbroot_LookAtProto()}
    set {_uniqueStorage()._lookAt = newValue}
  }
  /// Returns true if `lookAt` has been explicitly set.
  var hasLookAt: Bool {return _storage._lookAt != nil}
  /// Clears the value of `lookAt`. Subsequent reads from it will return its default value.
  mutating func clearLookAt() {_uniqueStorage()._lookAt = nil}

  /// The asset UUID is used by the Earth Plugin to provide a unique identifier
  /// that exposes the different layers via a JavaScript API.
  /// This string must be unique across *all* layers in the entire dbroot
  /// hierarchy.
  var assetUuid: String {
    get {return _storage._assetUuid ?? String()}
    set {_uniqueStorage()._assetUuid = newValue}
  }
  /// Returns true if `assetUuid` has been explicitly set.
  var hasAssetUuid: Bool {return _storage._assetUuid != nil}
  /// Clears the value of `assetUuid`. Subsequent reads from it will return its default value.
  mutating func clearAssetUuid() {_uniqueStorage()._assetUuid = nil}

  /// The save_locked field controls whether or not a placemark can be right-
  /// clicked and saved out to My Places.
  /// Note: Clients < 4.3 did not accurately use this feature, so everything was
  /// set to 'true'.
  var isSaveLocked: Bool {
    get {return _storage._isSaveLocked ?? true}
    set {_uniqueStorage()._isSaveLocked = newValue}
  }
  /// Returns true if `isSaveLocked` has been explicitly set.
  var hasIsSaveLocked: Bool {return _storage._isSaveLocked != nil}
  /// Clears the value of `isSaveLocked`. Subsequent reads from it will return its default value.
  mutating func clearIsSaveLocked() {_uniqueStorage()._isSaveLocked = nil}

  var children: [Keyhole_Dbroot_NestedFeatureProto] {
    get {return _storage._children}
    set {_uniqueStorage()._children = newValue}
  }

  /// Reference to client configuration script which is applied to every layer.
  /// This allows some layers to be turned off on certain clients based on
  /// decisions that must be made at runtime. The client is responsible for
  /// parsing and applying the script.
  var clientConfigScriptName: String {
    get {return _storage._clientConfigScriptName ?? String()}
    set {_uniqueStorage()._clientConfigScriptName = newValue}
  }
  /// Returns true if `clientConfigScriptName` has been explicitly set.
  var hasClientConfigScriptName: Bool {return _storage._clientConfigScriptName != nil}
  /// Clears the value of `clientConfigScriptName`. Subsequent reads from it will return its default value.
  mutating func clearClientConfigScriptName() {_uniqueStorage()._clientConfigScriptName = nil}

  /// This field is used only for Diorama layers, which may contain multiple
  /// data packets per tile for a single <etNestedLayer> entry in the dbroot.
  /// When this field is set to a positive integer, the client will fetch this
  /// layer's packets along with Diorama metadata indicating the number of
  /// packets per tile. For each packet i between 0 and number of packets per
  /// tile, the client will fetch data for layer diorama_data_channel_base + i;
  /// however, these layers do not appear in the dbroot.
  var dioramaDataChannelBase: Int32 {
    get {return _storage._dioramaDataChannelBase ?? -1}
    set {_uniqueStorage()._dioramaDataChannelBase = newValue}
  }
  /// Returns true if `dioramaDataChannelBase` has been explicitly set.
  var hasDioramaDataChannelBase: Bool {return _storage._dioramaDataChannelBase != nil}
  /// Clears the value of `dioramaDataChannelBase`. Subsequent reads from it will return its default value.
  mutating func clearDioramaDataChannelBase() {_uniqueStorage()._dioramaDataChannelBase = nil}

  /// This field is used only for 3D replica data (e.g. Trees) and uses the
  /// same mechanism as described in the diorama_data_channel_base field above.
  var replicaDataChannelBase: Int32 {
    get {return _storage._replicaDataChannelBase ?? -1}
    set {_uniqueStorage()._replicaDataChannelBase = newValue}
  }
  /// Returns true if `replicaDataChannelBase` has been explicitly set.
  var hasReplicaDataChannelBase: Bool {return _storage._replicaDataChannelBase != nil}
  /// Clears the value of `replicaDataChannelBase`. Subsequent reads from it will return its default value.
  mutating func clearReplicaDataChannelBase() {_uniqueStorage()._replicaDataChannelBase = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FeatureType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case typePointZ // = 1
    case typePolygonZ // = 2
    case typeLineZ // = 3

    /// This will soon be deprecated, do not use.
    case typeTerrain // = 4

    init() {
      self = .typePointZ
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .typePointZ
      case 2: self = .typePolygonZ
      case 3: self = .typeLineZ
      case 4: self = .typeTerrain
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .typePointZ: return 1
      case .typePolygonZ: return 2
      case .typeLineZ: return 3
      case .typeTerrain: return 4
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Keyhole_Dbroot_NestedFeatureProto.FeatureType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Deprecated in Earth 6.2 and higher in favor of search_config.
struct Keyhole_Dbroot_MfeDomainFeaturesProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 2-character country code for which these values apply
  var countryCode: String {
    get {return _countryCode ?? String()}
    set {_countryCode = newValue}
  }
  /// Returns true if `countryCode` has been explicitly set.
  var hasCountryCode: Bool {return self._countryCode != nil}
  /// Clears the value of `countryCode`. Subsequent reads from it will return its default value.
  mutating func clearCountryCode() {self._countryCode = nil}

  /// domain name to use for requests - e.g. maps.google.com (default
  /// protocol is http, default port is 80). If a full URL is specified,
  /// it will override the default maps url. Otherwise, if just a host is
  /// specified (as usual), the port, path and protocol of the default maps URL
  /// will be used to build the URL for this country.
  var domainName: String {
    get {return _domainName ?? String()}
    set {_domainName = newValue}
  }
  /// Returns true if `domainName` has been explicitly set.
  var hasDomainName: Bool {return self._domainName != nil}
  /// Clears the value of `domainName`. Subsequent reads from it will return its default value.
  mutating func clearDomainName() {self._domainName = nil}

  /// List of all available features. Duplicate entries are ignored.
  var supportedFeatures: [Keyhole_Dbroot_MfeDomainFeaturesProto.SupportedFeature] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// enum that lists all available features.
  enum SupportedFeature: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case geocoding // = 0
    case localSearch // = 1
    case drivingDirections // = 2

    init() {
      self = .geocoding
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .geocoding
      case 1: self = .localSearch
      case 2: self = .drivingDirections
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .geocoding: return 0
      case .localSearch: return 1
      case .drivingDirections: return 2
      }
    }

  }

  init() {}

  fileprivate var _countryCode: String? = nil
  fileprivate var _domainName: String? = nil
}

#if swift(>=4.2)

extension Keyhole_Dbroot_MfeDomainFeaturesProto.SupportedFeature: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Collection of various client features that can be enabled or disabled. Some
/// of these options are not really tied to the database.
struct Keyhole_Dbroot_ClientOptionsProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If true, no data will be cached on disk for this database. It will not
  /// be accessible offline.
  var disableDiskCache: Bool {
    get {return _storage._disableDiskCache ?? false}
    set {_uniqueStorage()._disableDiskCache = newValue}
  }
  /// Returns true if `disableDiskCache` has been explicitly set.
  var hasDisableDiskCache: Bool {return _storage._disableDiskCache != nil}
  /// Clears the value of `disableDiskCache`. Subsequent reads from it will return its default value.
  mutating func clearDisableDiskCache() {_uniqueStorage()._disableDiskCache = nil}

  /// If true, disables the embedded browser feature from Earth 5.1 and earlier
  /// when running on Vista or Windows 7.  This setting is deprecated, since it
  /// applies only to older clients that do not parse dbroot_proto anyway.
  var disableEmbeddedBrowserVista: Bool {
    get {return _storage._disableEmbeddedBrowserVista ?? false}
    set {_uniqueStorage()._disableEmbeddedBrowserVista = newValue}
  }
  /// Returns true if `disableEmbeddedBrowserVista` has been explicitly set.
  var hasDisableEmbeddedBrowserVista: Bool {return _storage._disableEmbeddedBrowserVista != nil}
  /// Clears the value of `disableEmbeddedBrowserVista`. Subsequent reads from it will return its default value.
  mutating func clearDisableEmbeddedBrowserVista() {_uniqueStorage()._disableEmbeddedBrowserVista = nil}

  /// Used to enable or disable the atmosphere. You may want to disable the
  /// atmosphere on the Moon, for instance.
  var drawAtmosphere: Bool {
    get {return _storage._drawAtmosphere ?? true}
    set {_uniqueStorage()._drawAtmosphere = newValue}
  }
  /// Returns true if `drawAtmosphere` has been explicitly set.
  var hasDrawAtmosphere: Bool {return _storage._drawAtmosphere != nil}
  /// Clears the value of `drawAtmosphere`. Subsequent reads from it will return its default value.
  mutating func clearDrawAtmosphere() {_uniqueStorage()._drawAtmosphere = nil}

  /// Used to enable drawing stars around the planet.
  var drawStars: Bool {
    get {return _storage._drawStars ?? true}
    set {_uniqueStorage()._drawStars = newValue}
  }
  /// Returns true if `drawStars` has been explicitly set.
  var hasDrawStars: Bool {return _storage._drawStars != nil}
  /// Clears the value of `drawStars`. Subsequent reads from it will return its default value.
  mutating func clearDrawStars() {_uniqueStorage()._drawStars = nil}

  /// Specifies the prefix to use for the names of the shader files.
  var shaderFilePrefix: String {
    get {return _storage._shaderFilePrefix ?? String()}
    set {_uniqueStorage()._shaderFilePrefix = newValue}
  }
  /// Returns true if `shaderFilePrefix` has been explicitly set.
  var hasShaderFilePrefix: Bool {return _storage._shaderFilePrefix != nil}
  /// Clears the value of `shaderFilePrefix`. Subsequent reads from it will return its default value.
  mutating func clearShaderFilePrefix() {_uniqueStorage()._shaderFilePrefix = nil}

  /// If set to true, this database uses protocol buffer quadtree packets.
  var useProtobufQuadtreePackets: Bool {
    get {return _storage._useProtobufQuadtreePackets ?? false}
    set {_uniqueStorage()._useProtobufQuadtreePackets = newValue}
  }
  /// Returns true if `useProtobufQuadtreePackets` has been explicitly set.
  var hasUseProtobufQuadtreePackets: Bool {return _storage._useProtobufQuadtreePackets != nil}
  /// Clears the value of `useProtobufQuadtreePackets`. Subsequent reads from it will return its default value.
  mutating func clearUseProtobufQuadtreePackets() {_uniqueStorage()._useProtobufQuadtreePackets = nil}

  /// If true, this database uses large copyright IDs (allows copyright ids
  /// larger than 255).
  var useExtendedCopyrightIds: Bool {
    get {return _storage._useExtendedCopyrightIds ?? true}
    set {_uniqueStorage()._useExtendedCopyrightIds = newValue}
  }
  /// Returns true if `useExtendedCopyrightIds` has been explicitly set.
  var hasUseExtendedCopyrightIds: Bool {return _storage._useExtendedCopyrightIds != nil}
  /// Clears the value of `useExtendedCopyrightIds`. Subsequent reads from it will return its default value.
  mutating func clearUseExtendedCopyrightIds() {_uniqueStorage()._useExtendedCopyrightIds = nil}

  var precipitationsOptions: Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions {
    get {return _storage._precipitationsOptions ?? Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions()}
    set {_uniqueStorage()._precipitationsOptions = newValue}
  }
  /// Returns true if `precipitationsOptions` has been explicitly set.
  var hasPrecipitationsOptions: Bool {return _storage._precipitationsOptions != nil}
  /// Clears the value of `precipitationsOptions`. Subsequent reads from it will return its default value.
  mutating func clearPrecipitationsOptions() {_uniqueStorage()._precipitationsOptions = nil}

  var captureOptions: Keyhole_Dbroot_ClientOptionsProto.CaptureOptions {
    get {return _storage._captureOptions ?? Keyhole_Dbroot_ClientOptionsProto.CaptureOptions()}
    set {_uniqueStorage()._captureOptions = newValue}
  }
  /// Returns true if `captureOptions` has been explicitly set.
  var hasCaptureOptions: Bool {return _storage._captureOptions != nil}
  /// Clears the value of `captureOptions`. Subsequent reads from it will return its default value.
  mutating func clearCaptureOptions() {_uniqueStorage()._captureOptions = nil}

  /// Controls whether or not the "Show in maps button" should be shown. On by
  /// default, typically set to false for EC databases.
  var show2DMapsIcon: Bool {
    get {return _storage._show2DMapsIcon ?? true}
    set {_uniqueStorage()._show2DMapsIcon = newValue}
  }
  /// Returns true if `show2DMapsIcon` has been explicitly set.
  var hasShow2DMapsIcon: Bool {return _storage._show2DMapsIcon != nil}
  /// Clears the value of `show2DMapsIcon`. Subsequent reads from it will return its default value.
  mutating func clearShow2DMapsIcon() {_uniqueStorage()._show2DMapsIcon = nil}

  /// If true, disables the internal browser feature for Earth 5.2 and later.
  var disableInternalBrowser: Bool {
    get {return _storage._disableInternalBrowser ?? false}
    set {_uniqueStorage()._disableInternalBrowser = newValue}
  }
  /// Returns true if `disableInternalBrowser` has been explicitly set.
  var hasDisableInternalBrowser: Bool {return _storage._disableInternalBrowser != nil}
  /// Clears the value of `disableInternalBrowser`. Subsequent reads from it will return its default value.
  mutating func clearDisableInternalBrowser() {_uniqueStorage()._disableInternalBrowser = nil}

  /// A whitespace-separated list of globbing patterns (using the * and ?
  /// wildcards) specifying URLs that are explicitly not allowed to open in the
  /// internal browser in Earth 5.2 and later.
  var internalBrowserBlacklist: String {
    get {return _storage._internalBrowserBlacklist ?? String()}
    set {_uniqueStorage()._internalBrowserBlacklist = newValue}
  }
  /// Returns true if `internalBrowserBlacklist` has been explicitly set.
  var hasInternalBrowserBlacklist: Bool {return _storage._internalBrowserBlacklist != nil}
  /// Clears the value of `internalBrowserBlacklist`. Subsequent reads from it will return its default value.
  mutating func clearInternalBrowserBlacklist() {_uniqueStorage()._internalBrowserBlacklist = nil}

  /// A whitespace-separated list of globbing patterns (using the * and ?
  /// wildcards) specifying URLs of origins for which KML content may open
  /// non-blacklisted links in the internal browser in Earth 5.2 and later.
  /// An "origin" refers to the path of the KML or KMZ file that contains the
  /// feature description that has the link in it.  The origin of a streamed
  /// layer is the URL at which it resides on its database server.
  var internalBrowserOriginWhitelist: String {
    get {return _storage._internalBrowserOriginWhitelist ?? "*"}
    set {_uniqueStorage()._internalBrowserOriginWhitelist = newValue}
  }
  /// Returns true if `internalBrowserOriginWhitelist` has been explicitly set.
  var hasInternalBrowserOriginWhitelist: Bool {return _storage._internalBrowserOriginWhitelist != nil}
  /// Clears the value of `internalBrowserOriginWhitelist`. Subsequent reads from it will return its default value.
  mutating func clearInternalBrowserOriginWhitelist() {_uniqueStorage()._internalBrowserOriginWhitelist = nil}

  /// Indicates whether the database supports merged polar image tiles,
  /// and if so at what zoom level the merging begins.  Values around 3
  /// are typical.  A value of zero or no value indicates that the
  /// database does not offer merged polar tiles.
  var polarTileMergingLevel: Int32 {
    get {return _storage._polarTileMergingLevel ?? 0}
    set {_uniqueStorage()._polarTileMergingLevel = newValue}
  }
  /// Returns true if `polarTileMergingLevel` has been explicitly set.
  var hasPolarTileMergingLevel: Bool {return _storage._polarTileMergingLevel != nil}
  /// Clears the value of `polarTileMergingLevel`. Subsequent reads from it will return its default value.
  mutating func clearPolarTileMergingLevel() {_uniqueStorage()._polarTileMergingLevel = nil}

  /// A whitespace-separated list of globbing patterns (using the * and ?
  /// wildcards) specifying URLs of origins from which the JavaScript bridge
  /// may make cross-domain requests on behalf of web content.  This should be
  /// set to an empty string for Fusion dbroots, and only Google domains should
  /// be whitelisted for the consumer clients.
  var jsBridgeRequestWhitelist: String {
    get {return _storage._jsBridgeRequestWhitelist ?? "http://*.google.com/*"}
    set {_uniqueStorage()._jsBridgeRequestWhitelist = newValue}
  }
  /// Returns true if `jsBridgeRequestWhitelist` has been explicitly set.
  var hasJsBridgeRequestWhitelist: Bool {return _storage._jsBridgeRequestWhitelist != nil}
  /// Clears the value of `jsBridgeRequestWhitelist`. Subsequent reads from it will return its default value.
  mutating func clearJsBridgeRequestWhitelist() {_uniqueStorage()._jsBridgeRequestWhitelist = nil}

  var mapsOptions: Keyhole_Dbroot_ClientOptionsProto.MapsOptions {
    get {return _storage._mapsOptions ?? Keyhole_Dbroot_ClientOptionsProto.MapsOptions()}
    set {_uniqueStorage()._mapsOptions = newValue}
  }
  /// Returns true if `mapsOptions` has been explicitly set.
  var hasMapsOptions: Bool {return _storage._mapsOptions != nil}
  /// Clears the value of `mapsOptions`. Subsequent reads from it will return its default value.
  mutating func clearMapsOptions() {_uniqueStorage()._mapsOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Nested message to control precipitation feature (rain and snow simulation)
  struct PrecipitationsOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// URL for doppler images.
    var imageURL: String {
      get {return _imageURL ?? String()}
      set {_imageURL = newValue}
    }
    /// Returns true if `imageURL` has been explicitly set.
    var hasImageURL: Bool {return self._imageURL != nil}
    /// Clears the value of `imageURL`. Subsequent reads from it will return its default value.
    mutating func clearImageURL() {self._imageURL = nil}

    /// Expiration time in seconds of doppler images.
    var imageExpireTime: Int32 {
      get {return _imageExpireTime ?? 900}
      set {_imageExpireTime = newValue}
    }
    /// Returns true if `imageExpireTime` has been explicitly set.
    var hasImageExpireTime: Bool {return self._imageExpireTime != nil}
    /// Clears the value of `imageExpireTime`. Subsequent reads from it will return its default value.
    mutating func clearImageExpireTime() {self._imageExpireTime = nil}

    /// Maximum squared distance threshold for choosing an element in the
    /// weather mapping.
    /// This is to account for small differences in the color tables from
    /// different areas (e.g. US vs. Europe). It also accounts for lossy
    /// compression artifacts.
    var maxColorDistance: Int32 {
      get {return _maxColorDistance ?? 20}
      set {_maxColorDistance = newValue}
    }
    /// Returns true if `maxColorDistance` has been explicitly set.
    var hasMaxColorDistance: Bool {return self._maxColorDistance != nil}
    /// Clears the value of `maxColorDistance`. Subsequent reads from it will return its default value.
    mutating func clearMaxColorDistance() {self._maxColorDistance = nil}

    /// Quadtree (zero-indexed) image level to fetch.
    /// Image level 5 corresponds to 6-digit filenames (e.g. 010310.png).
    var imageLevel: Int32 {
      get {return _imageLevel ?? 5}
      set {_imageLevel = newValue}
    }
    /// Returns true if `imageLevel` has been explicitly set.
    var hasImageLevel: Bool {return self._imageLevel != nil}
    /// Clears the value of `imageLevel`. Subsequent reads from it will return its default value.
    mutating func clearImageLevel() {self._imageLevel = nil}

    /// Maps weather map colors to rain/snow/fog/etc.
    var weatherMapping: [Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions.WeatherMapping] = []

    /// Clouds layer URL. This is used to detect whether the clouds layer
    /// is enabled.
    var cloudsLayerURL: String {
      get {return _cloudsLayerURL ?? String()}
      set {_cloudsLayerURL = newValue}
    }
    /// Returns true if `cloudsLayerURL` has been explicitly set.
    var hasCloudsLayerURL: Bool {return self._cloudsLayerURL != nil}
    /// Clears the value of `cloudsLayerURL`. Subsequent reads from it will return its default value.
    mutating func clearCloudsLayerURL() {self._cloudsLayerURL = nil}

    /// Delay in seconds before animation starts transitioning to a stop after
    /// any user os streaming activity.
    var animationDecelerationDelay: Float {
      get {return _animationDecelerationDelay ?? 20}
      set {_animationDecelerationDelay = newValue}
    }
    /// Returns true if `animationDecelerationDelay` has been explicitly set.
    var hasAnimationDecelerationDelay: Bool {return self._animationDecelerationDelay != nil}
    /// Clears the value of `animationDecelerationDelay`. Subsequent reads from it will return its default value.
    mutating func clearAnimationDecelerationDelay() {self._animationDecelerationDelay = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Describes an entry in the list that maps weather image colors
    /// to rain/snow/fog/etc.
    struct WeatherMapping {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Color that may be found in weather images.
      var colorAbgr: UInt32 {
        get {return _colorAbgr ?? 0}
        set {_colorAbgr = newValue}
      }
      /// Returns true if `colorAbgr` has been explicitly set.
      var hasColorAbgr: Bool {return self._colorAbgr != nil}
      /// Clears the value of `colorAbgr`. Subsequent reads from it will return its default value.
      mutating func clearColorAbgr() {self._colorAbgr = nil}

      /// No precipitation, raining, or snowing.
      var weatherType: Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions.WeatherMapping.WeatherType {
        get {return _weatherType ?? .noPrecipitation}
        set {_weatherType = newValue}
      }
      /// Returns true if `weatherType` has been explicitly set.
      var hasWeatherType: Bool {return self._weatherType != nil}
      /// Clears the value of `weatherType`. Subsequent reads from it will return its default value.
      mutating func clearWeatherType() {self._weatherType = nil}

      /// How much stretch or compress the rain/snow texture. Smaller
      /// (positive) values correspond to longer precipitation.
      var elongation: Float {
        get {return _elongation ?? 1}
        set {_elongation = newValue}
      }
      /// Returns true if `elongation` has been explicitly set.
      var hasElongation: Bool {return self._elongation != nil}
      /// Clears the value of `elongation`. Subsequent reads from it will return its default value.
      mutating func clearElongation() {self._elongation = nil}

      /// Texture's opacity.
      var opacity: Float {
        get {return _opacity ?? 0}
        set {_opacity = newValue}
      }
      /// Returns true if `opacity` has been explicitly set.
      var hasOpacity: Bool {return self._opacity != nil}
      /// Clears the value of `opacity`. Subsequent reads from it will return its default value.
      mutating func clearOpacity() {self._opacity = nil}

      /// Fog's density used in exp2 fog equation.
      var fogDensity: Float {
        get {return _fogDensity ?? 0}
        set {_fogDensity = newValue}
      }
      /// Returns true if `fogDensity` has been explicitly set.
      var hasFogDensity: Bool {return self._fogDensity != nil}
      /// Clears the value of `fogDensity`. Subsequent reads from it will return its default value.
      mutating func clearFogDensity() {self._fogDensity = nil}

      /// Speed for front-most texture layer.
      var speed0: Float {
        get {return _speed0 ?? 0}
        set {_speed0 = newValue}
      }
      /// Returns true if `speed0` has been explicitly set.
      var hasSpeed0: Bool {return self._speed0 != nil}
      /// Clears the value of `speed0`. Subsequent reads from it will return its default value.
      mutating func clearSpeed0() {self._speed0 = nil}

      /// Speed for second texture layer.
      var speed1: Float {
        get {return _speed1 ?? 0}
        set {_speed1 = newValue}
      }
      /// Returns true if `speed1` has been explicitly set.
      var hasSpeed1: Bool {return self._speed1 != nil}
      /// Clears the value of `speed1`. Subsequent reads from it will return its default value.
      mutating func clearSpeed1() {self._speed1 = nil}

      /// Speed for third texture layer.
      var speed2: Float {
        get {return _speed2 ?? 0}
        set {_speed2 = newValue}
      }
      /// Returns true if `speed2` has been explicitly set.
      var hasSpeed2: Bool {return self._speed2 != nil}
      /// Clears the value of `speed2`. Subsequent reads from it will return its default value.
      mutating func clearSpeed2() {self._speed2 = nil}

      /// Speed for back-most texture layer.
      var speed3: Float {
        get {return _speed3 ?? 0}
        set {_speed3 = newValue}
      }
      /// Returns true if `speed3` has been explicitly set.
      var hasSpeed3: Bool {return self._speed3 != nil}
      /// Clears the value of `speed3`. Subsequent reads from it will return its default value.
      mutating func clearSpeed3() {self._speed3 = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum WeatherType: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case noPrecipitation // = 0
        case rain // = 1
        case snow // = 2

        init() {
          self = .noPrecipitation
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .noPrecipitation
          case 1: self = .rain
          case 2: self = .snow
          default: return nil
          }
        }

        var rawValue: Int {
          switch self {
          case .noPrecipitation: return 0
          case .rain: return 1
          case .snow: return 2
          }
        }

      }

      init() {}

      fileprivate var _colorAbgr: UInt32? = nil
      fileprivate var _weatherType: Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions.WeatherMapping.WeatherType? = nil
      fileprivate var _elongation: Float? = nil
      fileprivate var _opacity: Float? = nil
      fileprivate var _fogDensity: Float? = nil
      fileprivate var _speed0: Float? = nil
      fileprivate var _speed1: Float? = nil
      fileprivate var _speed2: Float? = nil
      fileprivate var _speed3: Float? = nil
    }

    init() {}

    fileprivate var _imageURL: String? = nil
    fileprivate var _imageExpireTime: Int32? = nil
    fileprivate var _maxColorDistance: Int32? = nil
    fileprivate var _imageLevel: Int32? = nil
    fileprivate var _cloudsLayerURL: String? = nil
    fileprivate var _animationDecelerationDelay: Float? = nil
  }

  /// Nested message to control printing / image saving capability on main
  /// database. The default values match the client's default values in all
  /// versions up to the 5.0.1 maintenance release.
  struct CaptureOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Can enable or disable saving a screenshot as a JPG image.
    var allowSaveAsImage: Bool {
      get {return _allowSaveAsImage ?? true}
      set {_allowSaveAsImage = newValue}
    }
    /// Returns true if `allowSaveAsImage` has been explicitly set.
    var hasAllowSaveAsImage: Bool {return self._allowSaveAsImage != nil}
    /// Clears the value of `allowSaveAsImage`. Subsequent reads from it will return its default value.
    mutating func clearAllowSaveAsImage() {self._allowSaveAsImage = nil}

    /// Specifies the maximum capture resolution (in largest dimension) in the
    /// free client. The best image that can be captured will be
    /// max_free_capture_res * max_free_capture_res.
    var maxFreeCaptureRes: Int32 {
      get {return _maxFreeCaptureRes ?? 2400}
      set {_maxFreeCaptureRes = newValue}
    }
    /// Returns true if `maxFreeCaptureRes` has been explicitly set.
    var hasMaxFreeCaptureRes: Bool {return self._maxFreeCaptureRes != nil}
    /// Clears the value of `maxFreeCaptureRes`. Subsequent reads from it will return its default value.
    mutating func clearMaxFreeCaptureRes() {self._maxFreeCaptureRes = nil}

    /// Similar max limit for Pro/EC clients for premium printing. This limit
    /// should be higher than the max free capture resolution for obvious
    /// reasons.
    var maxPremiumCaptureRes: Int32 {
      get {return _maxPremiumCaptureRes ?? 4800}
      set {_maxPremiumCaptureRes = newValue}
    }
    /// Returns true if `maxPremiumCaptureRes` has been explicitly set.
    var hasMaxPremiumCaptureRes: Bool {return self._maxPremiumCaptureRes != nil}
    /// Clears the value of `maxPremiumCaptureRes`. Subsequent reads from it will return its default value.
    mutating func clearMaxPremiumCaptureRes() {self._maxPremiumCaptureRes = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _allowSaveAsImage: Bool? = nil
    fileprivate var _maxFreeCaptureRes: Int32? = nil
    fileprivate var _maxPremiumCaptureRes: Int32? = nil
  }

  /// Message with Maps documents options.
  struct MapsOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether to use maps library for managing documents.
    var enableMaps: Bool {
      get {return _enableMaps ?? false}
      set {_enableMaps = newValue}
    }
    /// Returns true if `enableMaps` has been explicitly set.
    var hasEnableMaps: Bool {return self._enableMaps != nil}
    /// Clears the value of `enableMaps`. Subsequent reads from it will return its default value.
    mutating func clearEnableMaps() {self._enableMaps = nil}

    /// Whether to enable auto download for polling docs server for feed and
    /// maps changes.
    var docsAutoDownloadEnabled: Bool {
      get {return _docsAutoDownloadEnabled ?? false}
      set {_docsAutoDownloadEnabled = newValue}
    }
    /// Returns true if `docsAutoDownloadEnabled` has been explicitly set.
    var hasDocsAutoDownloadEnabled: Bool {return self._docsAutoDownloadEnabled != nil}
    /// Clears the value of `docsAutoDownloadEnabled`. Subsequent reads from it will return its default value.
    mutating func clearDocsAutoDownloadEnabled() {self._docsAutoDownloadEnabled = nil}

    /// Interval in milliseconds of how often to poll docs server for feed and
    /// maps changes. Depends on docs_auto_download_enabled.
    var docsAutoDownloadInterval: Int32 {
      get {return _docsAutoDownloadInterval ?? 0}
      set {_docsAutoDownloadInterval = newValue}
    }
    /// Returns true if `docsAutoDownloadInterval` has been explicitly set.
    var hasDocsAutoDownloadInterval: Bool {return self._docsAutoDownloadInterval != nil}
    /// Clears the value of `docsAutoDownloadInterval`. Subsequent reads from it will return its default value.
    mutating func clearDocsAutoDownloadInterval() {self._docsAutoDownloadInterval = nil}

    /// Whether to enable auto uploads for new or modified maps.
    var docsAutoUploadEnabled: Bool {
      get {return _docsAutoUploadEnabled ?? false}
      set {_docsAutoUploadEnabled = newValue}
    }
    /// Returns true if `docsAutoUploadEnabled` has been explicitly set.
    var hasDocsAutoUploadEnabled: Bool {return self._docsAutoUploadEnabled != nil}
    /// Clears the value of `docsAutoUploadEnabled`. Subsequent reads from it will return its default value.
    mutating func clearDocsAutoUploadEnabled() {self._docsAutoUploadEnabled = nil}

    /// Delay in milliseconds of how long to wait before uploading local
    /// changes to docs maps. Depends on docs_upload_enabled.
    var docsAutoUploadDelay: Int32 {
      get {return _docsAutoUploadDelay ?? 0}
      set {_docsAutoUploadDelay = newValue}
    }
    /// Returns true if `docsAutoUploadDelay` has been explicitly set.
    var hasDocsAutoUploadDelay: Bool {return self._docsAutoUploadDelay != nil}
    /// Clears the value of `docsAutoUploadDelay`. Subsequent reads from it will return its default value.
    mutating func clearDocsAutoUploadDelay() {self._docsAutoUploadDelay = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _enableMaps: Bool? = nil
    fileprivate var _docsAutoDownloadEnabled: Bool? = nil
    fileprivate var _docsAutoDownloadInterval: Int32? = nil
    fileprivate var _docsAutoUploadEnabled: Bool? = nil
    fileprivate var _docsAutoUploadDelay: Int32? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions.WeatherMapping.WeatherType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Settings that affect how data can be fetched and throttled for this database.
/// Next available id: 16
struct Keyhole_Dbroot_FetchingOptionsProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Maximum number of nodes that can be asked for in a single request. If set
  /// to 1, clients will issue one request per node. Larger values allow clients
  /// to group requests together. This value impacts all the other
  /// batching-related options.
  var maxRequestsPerQuery: Int32 {
    get {return _maxRequestsPerQuery ?? 1}
    set {_maxRequestsPerQuery = newValue}
  }
  /// Returns true if `maxRequestsPerQuery` has been explicitly set.
  var hasMaxRequestsPerQuery: Bool {return self._maxRequestsPerQuery != nil}
  /// Clears the value of `maxRequestsPerQuery`. Subsequent reads from it will return its default value.
  mutating func clearMaxRequestsPerQuery() {self._maxRequestsPerQuery = nil}

  /// We allow the user to specify Connection/avoidRequestBatching
  /// in drivers.ini.  If force_max_requests_per_query is true,
  /// we ignore the user setting and use max_requests_per_query.
  var forceMaxRequestsPerQuery: Bool {
    get {return _forceMaxRequestsPerQuery ?? false}
    set {_forceMaxRequestsPerQuery = newValue}
  }
  /// Returns true if `forceMaxRequestsPerQuery` has been explicitly set.
  var hasForceMaxRequestsPerQuery: Bool {return self._forceMaxRequestsPerQuery != nil}
  /// Clears the value of `forceMaxRequestsPerQuery`. Subsequent reads from it will return its default value.
  mutating func clearForceMaxRequestsPerQuery() {self._forceMaxRequestsPerQuery = nil}

  /// Whether the client should sort requests before grouping requests together.
  var sortBatches: Bool {
    get {return _sortBatches ?? false}
    set {_sortBatches = newValue}
  }
  /// Returns true if `sortBatches` has been explicitly set.
  var hasSortBatches: Bool {return self._sortBatches != nil}
  /// Clears the value of `sortBatches`. Subsequent reads from it will return its default value.
  mutating func clearSortBatches() {self._sortBatches = nil}

  /// Maximum number of drawable packets per request.
  var maxDrawable: Int32 {
    get {return _maxDrawable ?? 2}
    set {_maxDrawable = newValue}
  }
  /// Returns true if `maxDrawable` has been explicitly set.
  var hasMaxDrawable: Bool {return self._maxDrawable != nil}
  /// Clears the value of `maxDrawable`. Subsequent reads from it will return its default value.
  mutating func clearMaxDrawable() {self._maxDrawable = nil}

  /// Maximum number of imagery packets per request.
  var maxImagery: Int32 {
    get {return _maxImagery ?? 2}
    set {_maxImagery = newValue}
  }
  /// Returns true if `maxImagery` has been explicitly set.
  var hasMaxImagery: Bool {return self._maxImagery != nil}
  /// Clears the value of `maxImagery`. Subsequent reads from it will return its default value.
  mutating func clearMaxImagery() {self._maxImagery = nil}

  /// Maximum number of terrain packets per request.
  var maxTerrain: Int32 {
    get {return _maxTerrain ?? 5}
    set {_maxTerrain = newValue}
  }
  /// Returns true if `maxTerrain` has been explicitly set.
  var hasMaxTerrain: Bool {return self._maxTerrain != nil}
  /// Clears the value of `maxTerrain`. Subsequent reads from it will return its default value.
  mutating func clearMaxTerrain() {self._maxTerrain = nil}

  /// Maximum number of quadtree packets per request.
  var maxQuadtree: Int32 {
    get {return _maxQuadtree ?? 5}
    set {_maxQuadtree = newValue}
  }
  /// Returns true if `maxQuadtree` has been explicitly set.
  var hasMaxQuadtree: Bool {return self._maxQuadtree != nil}
  /// Clears the value of `maxQuadtree`. Subsequent reads from it will return its default value.
  mutating func clearMaxQuadtree() {self._maxQuadtree = nil}

  /// Maximum number of diorama metadata packets per request.
  var maxDioramaMetadata: Int32 {
    get {return _maxDioramaMetadata ?? 1}
    set {_maxDioramaMetadata = newValue}
  }
  /// Returns true if `maxDioramaMetadata` has been explicitly set.
  var hasMaxDioramaMetadata: Bool {return self._maxDioramaMetadata != nil}
  /// Clears the value of `maxDioramaMetadata`. Subsequent reads from it will return its default value.
  mutating func clearMaxDioramaMetadata() {self._maxDioramaMetadata = nil}

  /// Maximum number of diorama data packets per request. The default is to not
  /// allow this packet type to be grouped with any other type, since these
  /// packets are typically quite large.
  var maxDioramaData: Int32 {
    get {return _maxDioramaData ?? 0}
    set {_maxDioramaData = newValue}
  }
  /// Returns true if `maxDioramaData` has been explicitly set.
  var hasMaxDioramaData: Bool {return self._maxDioramaData != nil}
  /// Clears the value of `maxDioramaData`. Subsequent reads from it will return its default value.
  mutating func clearMaxDioramaData() {self._maxDioramaData = nil}

  /// Fetch ratio for consumer builds (non-paying customers). The default is to
  /// limit the number of packets fetched per frame to a low number (4 in
  /// consumer builds). This ratio allows to increase that low number - a ratio
  /// of 10 bumps the max number of packets to 40 per frame. Allowing a large
  /// number of packets to be fetched per frame can significantly decrease scene
  /// resolution time. A value of 0 means to not restrict the amount of data
  /// fetched per frame at all (infinite ratio).
  var maxConsumerFetchRatio: Float {
    get {return _maxConsumerFetchRatio ?? 1}
    set {_maxConsumerFetchRatio = newValue}
  }
  /// Returns true if `maxConsumerFetchRatio` has been explicitly set.
  var hasMaxConsumerFetchRatio: Bool {return self._maxConsumerFetchRatio != nil}
  /// Clears the value of `maxConsumerFetchRatio`. Subsequent reads from it will return its default value.
  mutating func clearMaxConsumerFetchRatio() {self._maxConsumerFetchRatio = nil}

  /// Same ratio, for Pro and EC builds. The default is to not throttle these
  /// builds at all.
  var maxProEcFetchRatio: Float {
    get {return _maxProEcFetchRatio ?? 0}
    set {_maxProEcFetchRatio = newValue}
  }
  /// Returns true if `maxProEcFetchRatio` has been explicitly set.
  var hasMaxProEcFetchRatio: Bool {return self._maxProEcFetchRatio != nil}
  /// Clears the value of `maxProEcFetchRatio`. Subsequent reads from it will return its default value.
  mutating func clearMaxProEcFetchRatio() {self._maxProEcFetchRatio = nil}

  /// QPS throttle for all node types. Forces the client to not issue more
  /// requests than the given number. A batched request counts for a single
  /// request from a qps standpoint. If not set or 0.0f, limit is ignored and the
  /// client won't be throttled.
  var safeOverallQps: Float {
    get {return _safeOverallQps ?? 0}
    set {_safeOverallQps = newValue}
  }
  /// Returns true if `safeOverallQps` has been explicitly set.
  var hasSafeOverallQps: Bool {return self._safeOverallQps != nil}
  /// Clears the value of `safeOverallQps`. Subsequent reads from it will return its default value.
  mutating func clearSafeOverallQps() {self._safeOverallQps = nil}

  /// Same type of throttle for imagery requests only. Each imagery packet
  /// requested in a batch request counts as 1 request. This setting is effective
  /// to reduce overall bandwidth usage since imagery packets are the largest of
  /// the most commonly requested pakcets types.
  var safeImageryQps: Float {
    get {return _safeImageryQps ?? 0}
    set {_safeImageryQps = newValue}
  }
  /// Returns true if `safeImageryQps` has been explicitly set.
  var hasSafeImageryQps: Bool {return self._safeImageryQps != nil}
  /// Clears the value of `safeImageryQps`. Subsequent reads from it will return its default value.
  mutating func clearSafeImageryQps() {self._safeImageryQps = nil}

  /// List of domains for which the client should use the HTTPS protocol
  /// instead of standard HTTP, when client option is enabled (supported as
  /// of Earth 7.1).
  var domainsForHTTPS: String {
    get {return _domainsForHTTPS ?? "google.com gstatic.com"}
    set {_domainsForHTTPS = newValue}
  }
  /// Returns true if `domainsForHTTPS` has been explicitly set.
  var hasDomainsForHTTPS: Bool {return self._domainsForHTTPS != nil}
  /// Clears the value of `domainsForHTTPS`. Subsequent reads from it will return its default value.
  mutating func clearDomainsForHTTPS() {self._domainsForHTTPS = nil}

  /// List of hosts for which the client should use regular HTTP instead of
  /// HTTPS.  This is effectively a list of exceptions to the domains_for_https
  /// field above.  Supported as of Earth 7.1.1.x for x > 1888.
  /// Example:  "sketchup.google.com chart.apis.google.com" will cause the client
  /// to use HTTP for these hosts, even though they belong to a domain in the
  /// domains_for_https list above.
  var hostsForHTTP: String {
    get {return _hostsForHTTP ?? String()}
    set {_hostsForHTTP = newValue}
  }
  /// Returns true if `hostsForHTTP` has been explicitly set.
  var hasHostsForHTTP: Bool {return self._hostsForHTTP != nil}
  /// Clears the value of `hostsForHTTP`. Subsequent reads from it will return its default value.
  mutating func clearHostsForHTTP() {self._hostsForHTTP = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _maxRequestsPerQuery: Int32? = nil
  fileprivate var _forceMaxRequestsPerQuery: Bool? = nil
  fileprivate var _sortBatches: Bool? = nil
  fileprivate var _maxDrawable: Int32? = nil
  fileprivate var _maxImagery: Int32? = nil
  fileprivate var _maxTerrain: Int32? = nil
  fileprivate var _maxQuadtree: Int32? = nil
  fileprivate var _maxDioramaMetadata: Int32? = nil
  fileprivate var _maxDioramaData: Int32? = nil
  fileprivate var _maxConsumerFetchRatio: Float? = nil
  fileprivate var _maxProEcFetchRatio: Float? = nil
  fileprivate var _safeOverallQps: Float? = nil
  fileprivate var _safeImageryQps: Float? = nil
  fileprivate var _domainsForHTTPS: String? = nil
  fileprivate var _hostsForHTTP: String? = nil
}

struct Keyhole_Dbroot_TimeMachineOptionsProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Url of timemachine database. If set and non-empty, there is a time machine
  /// server associated to this database.
  var serverURL: String {
    get {return _serverURL ?? String()}
    set {_serverURL = newValue}
  }
  /// Returns true if `serverURL` has been explicitly set.
  var hasServerURL: Bool {return self._serverURL != nil}
  /// Clears the value of `serverURL`. Subsequent reads from it will return its default value.
  mutating func clearServerURL() {self._serverURL = nil}

  /// If set to true, this database is a time machine server.
  var isTimemachine: Bool {
    get {return _isTimemachine ?? false}
    set {_isTimemachine = newValue}
  }
  /// Returns true if `isTimemachine` has been explicitly set.
  var hasIsTimemachine: Bool {return self._isTimemachine != nil}
  /// Clears the value of `isTimemachine`. Subsequent reads from it will return its default value.
  mutating func clearIsTimemachine() {self._isTimemachine = nil}

  /// Number of milliseconds to wait since the last time change until we
  /// actually set the date used for time machine requests.
  var dwellTimeMs: Int32 {
    get {return _dwellTimeMs ?? 500}
    set {_dwellTimeMs = newValue}
  }
  /// Returns true if `dwellTimeMs` has been explicitly set.
  var hasDwellTimeMs: Bool {return self._dwellTimeMs != nil}
  /// Clears the value of `dwellTimeMs`. Subsequent reads from it will return its default value.
  mutating func clearDwellTimeMs() {self._dwellTimeMs = nil}

  /// The camera altitude (in meters) below which the client is allowed to
  /// expose timemachine dates to the user to inform her that interesting data
  /// exists.  The default value is 15 km.
  var discoverabilityAltitudeMeters: Int32 {
    get {return _discoverabilityAltitudeMeters ?? 15000}
    set {_discoverabilityAltitudeMeters = newValue}
  }
  /// Returns true if `discoverabilityAltitudeMeters` has been explicitly set.
  var hasDiscoverabilityAltitudeMeters: Bool {return self._discoverabilityAltitudeMeters != nil}
  /// Clears the value of `discoverabilityAltitudeMeters`. Subsequent reads from it will return its default value.
  mutating func clearDiscoverabilityAltitudeMeters() {self._discoverabilityAltitudeMeters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serverURL: String? = nil
  fileprivate var _isTimemachine: Bool? = nil
  fileprivate var _dwellTimeMs: Int32? = nil
  fileprivate var _discoverabilityAltitudeMeters: Int32? = nil
}

struct Keyhole_Dbroot_AutopiaOptionsProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Url of the cityblock server from which to fetch the panorama
  /// metadata.
  var metadataServerURL: String {
    get {return _metadataServerURL ?? "http://cbk0.google.com/cbk"}
    set {_metadataServerURL = newValue}
  }
  /// Returns true if `metadataServerURL` has been explicitly set.
  var hasMetadataServerURL: Bool {return self._metadataServerURL != nil}
  /// Clears the value of `metadataServerURL`. Subsequent reads from it will return its default value.
  mutating func clearMetadataServerURL() {self._metadataServerURL = nil}

  /// Url of the cityblock server from which to fetch the depthmaps
  var depthmapServerURL: String {
    get {return _depthmapServerURL ?? "http://cbk0.google.com/cbk"}
    set {_depthmapServerURL = newValue}
  }
  /// Returns true if `depthmapServerURL` has been explicitly set.
  var hasDepthmapServerURL: Bool {return self._depthmapServerURL != nil}
  /// Clears the value of `depthmapServerURL`. Subsequent reads from it will return its default value.
  mutating func clearDepthmapServerURL() {self._depthmapServerURL = nil}

  /// Url of the coverage overlay KML. Not specifying this value will
  /// result in no coverage overlays being shown while dragging the
  /// pegman in autopia.
  var coverageOverlayURL: String {
    get {return _coverageOverlayURL ?? String()}
    set {_coverageOverlayURL = newValue}
  }
  /// Returns true if `coverageOverlayURL` has been explicitly set.
  var hasCoverageOverlayURL: Bool {return self._coverageOverlayURL != nil}
  /// Clears the value of `coverageOverlayURL`. Subsequent reads from it will return its default value.
  mutating func clearCoverageOverlayURL() {self._coverageOverlayURL = nil}

  /// QPS throttle for Autopia imagery requests. If not set or 0.0f,
  /// limit is ignored and the client won't be throttled. We have a separate
  /// throttle for imagery requests as they are the most common type of requests.
  ///
  /// If we set an identical throttle value to imagery and metadata-depthmap,
  /// then requests can share the http connection. On the other hand they will
  /// use two different connections for different values. This enables us to
  /// throttle imagery without throttling metadata.
  var maxImageryQps: Float {
    get {return _maxImageryQps ?? 0}
    set {_maxImageryQps = newValue}
  }
  /// Returns true if `maxImageryQps` has been explicitly set.
  var hasMaxImageryQps: Bool {return self._maxImageryQps != nil}
  /// Clears the value of `maxImageryQps`. Subsequent reads from it will return its default value.
  mutating func clearMaxImageryQps() {self._maxImageryQps = nil}

  /// QPS throttle for Autopia metadata and depthmap requests.
  var maxMetadataDepthmapQps: Float {
    get {return _maxMetadataDepthmapQps ?? 0}
    set {_maxMetadataDepthmapQps = newValue}
  }
  /// Returns true if `maxMetadataDepthmapQps` has been explicitly set.
  var hasMaxMetadataDepthmapQps: Bool {return self._maxMetadataDepthmapQps != nil}
  /// Clears the value of `maxMetadataDepthmapQps`. Subsequent reads from it will return its default value.
  mutating func clearMaxMetadataDepthmapQps() {self._maxMetadataDepthmapQps = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadataServerURL: String? = nil
  fileprivate var _depthmapServerURL: String? = nil
  fileprivate var _coverageOverlayURL: String? = nil
  fileprivate var _maxImageryQps: Float? = nil
  fileprivate var _maxMetadataDepthmapQps: Float? = nil
}

/// Settings that control the client's interaction with the CSI logging server.
/// Only useful for the main database.
struct Keyhole_Dbroot_CSIOptionsProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The percentage of authenticated non-EC logins to send to CSI.
  var samplingPercentage: Int32 {
    get {return _samplingPercentage ?? 0}
    set {_samplingPercentage = newValue}
  }
  /// Returns true if `samplingPercentage` has been explicitly set.
  var hasSamplingPercentage: Bool {return self._samplingPercentage != nil}
  /// Clears the value of `samplingPercentage`. Subsequent reads from it will return its default value.
  mutating func clearSamplingPercentage() {self._samplingPercentage = nil}

  /// A string used to tag samples sent to CSI as part of an experiment.
  /// This string is passed as a CGI parameter of the URL and is expected
  /// to be URL-friendly.
  var experimentID: String {
    get {return _experimentID ?? String()}
    set {_experimentID = newValue}
  }
  /// Returns true if `experimentID` has been explicitly set.
  var hasExperimentID: Bool {return self._experimentID != nil}
  /// Clears the value of `experimentID`. Subsequent reads from it will return its default value.
  mutating func clearExperimentID() {self._experimentID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _samplingPercentage: Int32? = nil
  fileprivate var _experimentID: String? = nil
}

struct Keyhole_Dbroot_SearchTabProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If false, tab is hidden.
  var isVisible: Bool {
    get {return _isVisible ?? false}
    set {_isVisible = newValue}
  }
  /// Returns true if `isVisible` has been explicitly set.
  var hasIsVisible: Bool {return self._isVisible != nil}
  /// Clears the value of `isVisible`. Subsequent reads from it will return its default value.
  mutating func clearIsVisible() {self._isVisible = nil}

  /// Name printed on tab.
  var tabLabel: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _tabLabel ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_tabLabel = newValue}
  }
  /// Returns true if `tabLabel` has been explicitly set.
  var hasTabLabel: Bool {return self._tabLabel != nil}
  /// Clears the value of `tabLabel`. Subsequent reads from it will return its default value.
  mutating func clearTabLabel() {self._tabLabel = nil}

  /// Base url for searches on this tab. This can contain a host, port, path
  /// and base query. Extra query parameter will be added to this URL to form
  /// the final URL.
  var baseURL: String {
    get {return _baseURL ?? String()}
    set {_baseURL = newValue}
  }
  /// Returns true if `baseURL` has been explicitly set.
  var hasBaseURL: Bool {return self._baseURL != nil}
  /// Clears the value of `baseURL`. Subsequent reads from it will return its default value.
  mutating func clearBaseURL() {self._baseURL = nil}

  /// Prefix added to viewport query
  var viewportPrefix: String {
    get {return _viewportPrefix ?? String()}
    set {_viewportPrefix = newValue}
  }
  /// Returns true if `viewportPrefix` has been explicitly set.
  var hasViewportPrefix: Bool {return self._viewportPrefix != nil}
  /// Clears the value of `viewportPrefix`. Subsequent reads from it will return its default value.
  mutating func clearViewportPrefix() {self._viewportPrefix = nil}

  /// List of input boxes. Most clients support only two input boxes.
  var inputBox: [Keyhole_Dbroot_SearchTabProto.InputBoxInfo] = []

  /// Requirement for showing search tab.
  /// This requirement is ignored for clients before 6.2 (i.e. it does not
  /// affect the search tab visibility for older clients).
  /// Version support: 6.2 +
  var requirement: Keyhole_Dbroot_RequirementProto {
    get {return _requirement ?? Keyhole_Dbroot_RequirementProto()}
    set {_requirement = newValue}
  }
  /// Returns true if `requirement` has been explicitly set.
  var hasRequirement: Bool {return self._requirement != nil}
  /// Clears the value of `requirement`. Subsequent reads from it will return its default value.
  mutating func clearRequirement() {self._requirement = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes a single input box - the label it should have and how its
  /// contents should be sent with the search query.
  struct InputBoxInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Label next to tag.
    var label: Keyhole_Dbroot_StringIdOrValueProto {
      get {return _label ?? Keyhole_Dbroot_StringIdOrValueProto()}
      set {_label = newValue}
    }
    /// Returns true if `label` has been explicitly set.
    var hasLabel: Bool {return self._label != nil}
    /// Clears the value of `label`. Subsequent reads from it will return its default value.
    mutating func clearLabel() {self._label = nil}

    /// Query param (verb)
    var queryVerb: String {
      get {return _queryVerb ?? String()}
      set {_queryVerb = newValue}
    }
    /// Returns true if `queryVerb` has been explicitly set.
    var hasQueryVerb: Bool {return self._queryVerb != nil}
    /// Clears the value of `queryVerb`. Subsequent reads from it will return its default value.
    mutating func clearQueryVerb() {self._queryVerb = nil}

    /// String prepended to input parameter
    var queryPrepend: String {
      get {return _queryPrepend ?? String()}
      set {_queryPrepend = newValue}
    }
    /// Returns true if `queryPrepend` has been explicitly set.
    var hasQueryPrepend: Bool {return self._queryPrepend != nil}
    /// Clears the value of `queryPrepend`. Subsequent reads from it will return its default value.
    mutating func clearQueryPrepend() {self._queryPrepend = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _label: Keyhole_Dbroot_StringIdOrValueProto? = nil
    fileprivate var _queryVerb: String? = nil
    fileprivate var _queryPrepend: String? = nil
  }

  init() {}

  fileprivate var _isVisible: Bool? = nil
  fileprivate var _tabLabel: Keyhole_Dbroot_StringIdOrValueProto? = nil
  fileprivate var _baseURL: String? = nil
  fileprivate var _viewportPrefix: String? = nil
  fileprivate var _requirement: Keyhole_Dbroot_RequirementProto? = nil
}

/// Defines position and size of custom logos that will be fetched and shown
/// by the client.
struct Keyhole_Dbroot_CobrandProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// URL of image to use as logo. Can be remote or local. However, using local
  /// URLs depends on the installation of the client and should be used
  /// carefully.
  var logoURL: String {
    get {return _logoURL ?? String()}
    set {_logoURL = newValue}
  }
  /// Returns true if `logoURL` has been explicitly set.
  var hasLogoURL: Bool {return self._logoURL != nil}
  /// Clears the value of `logoURL`. Subsequent reads from it will return its default value.
  mutating func clearLogoURL() {self._logoURL = nil}

  /// Controls x position of reference overlay point (see tie_point)
  var xCoord: Keyhole_Dbroot_CobrandProto.Coord {
    get {return _xCoord ?? Keyhole_Dbroot_CobrandProto.Coord()}
    set {_xCoord = newValue}
  }
  /// Returns true if `xCoord` has been explicitly set.
  var hasXCoord: Bool {return self._xCoord != nil}
  /// Clears the value of `xCoord`. Subsequent reads from it will return its default value.
  mutating func clearXCoord() {self._xCoord = nil}

  /// Controls y position of reference overlay point (see tie_point)
  var yCoord: Keyhole_Dbroot_CobrandProto.Coord {
    get {return _yCoord ?? Keyhole_Dbroot_CobrandProto.Coord()}
    set {_yCoord = newValue}
  }
  /// Returns true if `yCoord` has been explicitly set.
  var hasYCoord: Bool {return self._yCoord != nil}
  /// Clears the value of `yCoord`. Subsequent reads from it will return its default value.
  mutating func clearYCoord() {self._yCoord = nil}

  /// Controls reference point in overlay.
  var tiePoint: Keyhole_Dbroot_CobrandProto.TiePoint {
    get {return _tiePoint ?? .bottomLeft}
    set {_tiePoint = newValue}
  }
  /// Returns true if `tiePoint` has been explicitly set.
  var hasTiePoint: Bool {return self._tiePoint != nil}
  /// Clears the value of `tiePoint`. Subsequent reads from it will return its default value.
  mutating func clearTiePoint() {self._tiePoint = nil}

  /// If specified and strictly positive but <= 1.0, makes logo scalable with
  /// screen by forcing its width to occupy a fixed fraction of the screeen.
  /// For instance, a value of .25 makes the given logo occupy 25% of the screen.
  var screenSize: Double {
    get {return _screenSize ?? 0}
    set {_screenSize = newValue}
  }
  /// Returns true if `screenSize` has been explicitly set.
  var hasScreenSize: Bool {return self._screenSize != nil}
  /// Clears the value of `screenSize`. Subsequent reads from it will return its default value.
  mutating func clearScreenSize() {self._screenSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TiePoint: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case topLeft // = 0
    case topCenter // = 1
    case topRight // = 2
    case midLeft // = 3
    case midCenter // = 4
    case midRight // = 5
    case bottomLeft // = 6
    case bottomCenter // = 7
    case bottomRight // = 8

    init() {
      self = .topLeft
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .topLeft
      case 1: self = .topCenter
      case 2: self = .topRight
      case 3: self = .midLeft
      case 4: self = .midCenter
      case 5: self = .midRight
      case 6: self = .bottomLeft
      case 7: self = .bottomCenter
      case 8: self = .bottomRight
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .topLeft: return 0
      case .topCenter: return 1
      case .topRight: return 2
      case .midLeft: return 3
      case .midCenter: return 4
      case .midRight: return 5
      case .bottomLeft: return 6
      case .bottomCenter: return 7
      case .bottomRight: return 8
      }
    }

  }

  /// Inner message that allows specifying a coordinate.
  struct Coord {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Coordinate value. Interpretation depends on is_relative (absolute or
    var value: Double {
      get {return _value ?? 0}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    /// If true, the coordinate is relative to the screen.
    var isRelative: Bool {
      get {return _isRelative ?? false}
      set {_isRelative = newValue}
    }
    /// Returns true if `isRelative` has been explicitly set.
    var hasIsRelative: Bool {return self._isRelative != nil}
    /// Clears the value of `isRelative`. Subsequent reads from it will return its default value.
    mutating func clearIsRelative() {self._isRelative = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _value: Double? = nil
    fileprivate var _isRelative: Bool? = nil
  }

  init() {}

  fileprivate var _logoURL: String? = nil
  fileprivate var _xCoord: Keyhole_Dbroot_CobrandProto.Coord? = nil
  fileprivate var _yCoord: Keyhole_Dbroot_CobrandProto.Coord? = nil
  fileprivate var _tiePoint: Keyhole_Dbroot_CobrandProto.TiePoint? = nil
  fileprivate var _screenSize: Double? = nil
}

#if swift(>=4.2)

extension Keyhole_Dbroot_CobrandProto.TiePoint: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Describes a database the client can connect to when connected to this server.
struct Keyhole_Dbroot_DatabaseDescriptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Human-readable name of database (such as "Primary Database" or "Digital
  /// Globe Database")
  var databaseName: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _databaseName ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_databaseName = newValue}
  }
  /// Returns true if `databaseName` has been explicitly set.
  var hasDatabaseName: Bool {return self._databaseName != nil}
  /// Clears the value of `databaseName`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseName() {self._databaseName = nil}

  /// URL of server. This can include a path and query, and must be a
  /// well-formed, absolute URL.
  var databaseURL: String {
    get {return _databaseURL ?? String()}
    set {_databaseURL = newValue}
  }
  /// Returns true if `databaseURL` has been explicitly set.
  var hasDatabaseURL: Bool {return self._databaseURL != nil}
  /// Clears the value of `databaseURL`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseURL() {self._databaseURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _databaseName: Keyhole_Dbroot_StringIdOrValueProto? = nil
  fileprivate var _databaseURL: String? = nil
}

/// Name/value pair that maps a script name to an alchemy script.
struct Keyhole_Dbroot_ConfigScriptProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the script that can be used in NestedFeatureProto (see
  /// client_config_script_name).
  var scriptName: String {
    get {return _scriptName ?? String()}
    set {_scriptName = newValue}
  }
  /// Returns true if `scriptName` has been explicitly set.
  var hasScriptName: Bool {return self._scriptName != nil}
  /// Clears the value of `scriptName`. Subsequent reads from it will return its default value.
  mutating func clearScriptName() {self._scriptName = nil}

  /// Contents of the script. This must be a valid Alchemy script.
  var scriptData: String {
    get {return _scriptData ?? String()}
    set {_scriptData = newValue}
  }
  /// Returns true if `scriptData` has been explicitly set.
  var hasScriptData: Bool {return self._scriptData != nil}
  /// Clears the value of `scriptData`. Subsequent reads from it will return its default value.
  mutating func clearScriptData() {self._scriptData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scriptName: String? = nil
  fileprivate var _scriptData: String? = nil
}

/// Setting to control the swoop feature in Google Earth. We can use it to reduce
/// the amount of tilt generated by swooping and thefore reduce overall
/// traffic (tilted views cause more tiles to be downloaded than non-tilted
/// ones).
struct Keyhole_Dbroot_SwoopParamsProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Controls how far from a target swooping should start.
  var startDistInMeters: Double {
    get {return _startDistInMeters ?? 0}
    set {_startDistInMeters = newValue}
  }
  /// Returns true if `startDistInMeters` has been explicitly set.
  var hasStartDistInMeters: Bool {return self._startDistInMeters != nil}
  /// Clears the value of `startDistInMeters`. Subsequent reads from it will return its default value.
  mutating func clearStartDistInMeters() {self._startDistInMeters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startDistInMeters: Double? = nil
}

/// Group of settings that can describe a BBS server where user can post their
/// data or report errors in our imagery or data.
struct Keyhole_Dbroot_PostingServerProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name that will be displayed in context menu to user. Must be translated.
  var name: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _name ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// URL of the server including protocol, domain and port. Can be translated
  /// if we use different servers for different languages.
  var baseURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _baseURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_baseURL = newValue}
  }
  /// Returns true if `baseURL` has been explicitly set.
  var hasBaseURL: Bool {return self._baseURL != nil}
  /// Clears the value of `baseURL`. Subsequent reads from it will return its default value.
  mutating func clearBaseURL() {self._baseURL = nil}

  /// Path on server where wizard can be found.
  var postWizardPath: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _postWizardPath ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_postWizardPath = newValue}
  }
  /// Returns true if `postWizardPath` has been explicitly set.
  var hasPostWizardPath: Bool {return self._postWizardPath != nil}
  /// Clears the value of `postWizardPath`. Subsequent reads from it will return its default value.
  mutating func clearPostWizardPath() {self._postWizardPath = nil}

  /// Path on server where files can be submitted.
  var fileSubmitPath: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _fileSubmitPath ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_fileSubmitPath = newValue}
  }
  /// Returns true if `fileSubmitPath` has been explicitly set.
  var hasFileSubmitPath: Bool {return self._fileSubmitPath != nil}
  /// Clears the value of `fileSubmitPath`. Subsequent reads from it will return its default value.
  mutating func clearFileSubmitPath() {self._fileSubmitPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: Keyhole_Dbroot_StringIdOrValueProto? = nil
  fileprivate var _baseURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
  fileprivate var _postWizardPath: Keyhole_Dbroot_StringIdOrValueProto? = nil
  fileprivate var _fileSubmitPath: Keyhole_Dbroot_StringIdOrValueProto? = nil
}

/// Describes a database for another planet or satellite (e.g. Mars, Moon)
/// accessible from this database (e.g. Earth).
struct Keyhole_Dbroot_PlanetaryDatabaseProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Full URL of database that will be used as base URL to request data.
  var url: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _url ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  /// Translated name of database - will be displayed to the user.
  var name: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _name ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _url: Keyhole_Dbroot_StringIdOrValueProto? = nil
  fileprivate var _name: Keyhole_Dbroot_StringIdOrValueProto? = nil
}

/// Group of settings to configure logging server used by Google Earth clients
/// that connect to this database.
struct Keyhole_Dbroot_LogServerProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Full url of logging server. Can be translated or specified as a string.
  /// The default value in Google Earth 5.1 is
  /// http://www.google.com/tbproxy/usagestats?sourceid=GoogleEarth
  var url: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _url ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  /// Specifies if logging should be performed. By default logging is turned off.
  var enable: Bool {
    get {return _enable ?? false}
    set {_enable = newValue}
  }
  /// Returns true if `enable` has been explicitly set.
  var hasEnable: Bool {return self._enable != nil}
  /// Clears the value of `enable`. Subsequent reads from it will return its default value.
  mutating func clearEnable() {self._enable = nil}

  /// Controls log throttling - a fraction of 1.0 / throttling_factor() sessions
  /// will be logged. A value of 1 means no throttling, while a value of 100
  /// causes only 1% of sessions to log data.
  var throttlingFactor: Int32 {
    get {return _throttlingFactor ?? 1}
    set {_throttlingFactor = newValue}
  }
  /// Returns true if `throttlingFactor` has been explicitly set.
  var hasThrottlingFactor: Bool {return self._throttlingFactor != nil}
  /// Clears the value of `throttlingFactor`. Subsequent reads from it will return its default value.
  mutating func clearThrottlingFactor() {self._throttlingFactor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _url: Keyhole_Dbroot_StringIdOrValueProto? = nil
  fileprivate var _enable: Bool? = nil
  fileprivate var _throttlingFactor: Int32? = nil
}

struct Keyhole_Dbroot_EndSnippetProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Options that describe planet shape.
  var model: Keyhole_Dbroot_PlanetModelProto {
    get {return _storage._model ?? Keyhole_Dbroot_PlanetModelProto()}
    set {_uniqueStorage()._model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  var hasModel: Bool {return _storage._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  mutating func clearModel() {_uniqueStorage()._model = nil}

  /// URL of authentication server for paying customers.
  /// e.g. "auth.keyhole.com". This can actually be a URL and contain a port,
  /// a path, and a protocol (such as https://server.company.com:8080/auth)
  var authServerURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._authServerURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._authServerURL = newValue}
  }
  /// Returns true if `authServerURL` has been explicitly set.
  var hasAuthServerURL: Bool {return _storage._authServerURL != nil}
  /// Clears the value of `authServerURL`. Subsequent reads from it will return its default value.
  mutating func clearAuthServerURL() {_uniqueStorage()._authServerURL = nil}

  /// Flag that can be used by entreprise customers - indicates that this
  /// database does not require session cookie-based authentication. Entreprise
  /// databases are typically protected with LDAP over HTTP or HTTPS.  Be *very*
  /// careful to never set this to true for kh.google.com or any other database
  /// we control unless you know for a fact it's the right thing to do.
  var disableAuthentication: Bool {
    get {return _storage._disableAuthentication ?? false}
    set {_uniqueStorage()._disableAuthentication = newValue}
  }
  /// Returns true if `disableAuthentication` has been explicitly set.
  var hasDisableAuthentication: Bool {return _storage._disableAuthentication != nil}
  /// Clears the value of `disableAuthentication`. Subsequent reads from it will return its default value.
  mutating func clearDisableAuthentication() {_uniqueStorage()._disableAuthentication = nil}

  /// Deprecated in Earth 6.1 and higher in favor of search_config.
  /// For each known country, lists maps domains to use and associated enabled
  /// features. For instance, some countries might be launched without
  /// localsearch support.
  var mfeDomains: [Keyhole_Dbroot_MfeDomainFeaturesProto] {
    get {return _storage._mfeDomains}
    set {_uniqueStorage()._mfeDomains = newValue}
  }

  /// Deprecated in Earth 6.1 and higher.
  /// Parameter(s) that should sent with each request to MFE.
  /// '[' or ']' does not seem to be valid in default values, it causes
  /// errors when compiling the code. 0x5B and 0xx5D are their respective
  /// hex ascii codes.
  /// Note: it is valid to specifiy multiple parameters, for instance:
  /// end_snippet->set_mfe_lang_param("hl=$[hl]&gl=$[gl]");
  var mfeLangParam: String {
    get {return _storage._mfeLangParam ?? "hl=$[hl]"}
    set {_uniqueStorage()._mfeLangParam = newValue}
  }
  /// Returns true if `mfeLangParam` has been explicitly set.
  var hasMfeLangParam: Bool {return _storage._mfeLangParam != nil}
  /// Clears the value of `mfeLangParam`. Subsequent reads from it will return its default value.
  mutating func clearMfeLangParam() {_uniqueStorage()._mfeLangParam = nil}

  /// List of space-separated strings treated as glob patterns that describe
  /// which URLs should be treated as ads URLs and never be fetched by the
  /// client. The default value in the client is:
  /// "http://*doubleclick.net* http://*googlesyndication.com* "
  /// "http://*google.com/aclk* http://*googleadservices.com* */pagead/*"
  var adsURLPatterns: String {
    get {return _storage._adsURLPatterns ?? String()}
    set {_uniqueStorage()._adsURLPatterns = newValue}
  }
  /// Returns true if `adsURLPatterns` has been explicitly set.
  var hasAdsURLPatterns: Bool {return _storage._adsURLPatterns != nil}
  /// Clears the value of `adsURLPatterns`. Subsequent reads from it will return its default value.
  mutating func clearAdsURLPatterns() {_uniqueStorage()._adsURLPatterns = nil}

  /// Reverse geocoder server URL
  var reverseGeocoderURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._reverseGeocoderURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._reverseGeocoderURL = newValue}
  }
  /// Returns true if `reverseGeocoderURL` has been explicitly set.
  var hasReverseGeocoderURL: Bool {return _storage._reverseGeocoderURL != nil}
  /// Clears the value of `reverseGeocoderURL`. Subsequent reads from it will return its default value.
  mutating func clearReverseGeocoderURL() {_uniqueStorage()._reverseGeocoderURL = nil}

  /// Reverse geocoder protocol version. Default is 3 which is the
  /// protocol supported by newer clients.
  var reverseGeocoderProtocolVersion: Int32 {
    get {return _storage._reverseGeocoderProtocolVersion ?? 3}
    set {_uniqueStorage()._reverseGeocoderProtocolVersion = newValue}
  }
  /// Returns true if `reverseGeocoderProtocolVersion` has been explicitly set.
  var hasReverseGeocoderProtocolVersion: Bool {return _storage._reverseGeocoderProtocolVersion != nil}
  /// Clears the value of `reverseGeocoderProtocolVersion`. Subsequent reads from it will return its default value.
  mutating func clearReverseGeocoderProtocolVersion() {_uniqueStorage()._reverseGeocoderProtocolVersion = nil}

  /// Whether or not sky database is present
  var skyDatabaseIsAvailable: Bool {
    get {return _storage._skyDatabaseIsAvailable ?? true}
    set {_uniqueStorage()._skyDatabaseIsAvailable = newValue}
  }
  /// Returns true if `skyDatabaseIsAvailable` has been explicitly set.
  var hasSkyDatabaseIsAvailable: Bool {return _storage._skyDatabaseIsAvailable != nil}
  /// Clears the value of `skyDatabaseIsAvailable`. Subsequent reads from it will return its default value.
  mutating func clearSkyDatabaseIsAvailable() {_uniqueStorage()._skyDatabaseIsAvailable = nil}

  /// Location of sky database URL.
  /// e.g. "http://khmdb.google.com?db=sky"
  var skyDatabaseURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._skyDatabaseURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._skyDatabaseURL = newValue}
  }
  /// Returns true if `skyDatabaseURL` has been explicitly set.
  var hasSkyDatabaseURL: Bool {return _storage._skyDatabaseURL != nil}
  /// Clears the value of `skyDatabaseURL`. Subsequent reads from it will return its default value.
  mutating func clearSkyDatabaseURL() {_uniqueStorage()._skyDatabaseURL = nil}

  /// Default location of web page.
  /// e.g. "http://www.google.com/intl/%1/";
  var defaultWebPageIntlURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._defaultWebPageIntlURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._defaultWebPageIntlURL = newValue}
  }
  /// Returns true if `defaultWebPageIntlURL` has been explicitly set.
  var hasDefaultWebPageIntlURL: Bool {return _storage._defaultWebPageIntlURL != nil}
  /// Clears the value of `defaultWebPageIntlURL`. Subsequent reads from it will return its default value.
  mutating func clearDefaultWebPageIntlURL() {_uniqueStorage()._defaultWebPageIntlURL = nil}

  /// DEPRECATED as of version 7.0.
  /// Controls the number of start-up tip urls that the client will cycle
  /// through before repeating. This should be no greater than the number of
  /// startup tips available on the server.
  var numStartUpTips: Int32 {
    get {return _storage._numStartUpTips ?? 17}
    set {_uniqueStorage()._numStartUpTips = newValue}
  }
  /// Returns true if `numStartUpTips` has been explicitly set.
  var hasNumStartUpTips: Bool {return _storage._numStartUpTips != nil}
  /// Clears the value of `numStartUpTips`. Subsequent reads from it will return its default value.
  mutating func clearNumStartUpTips() {_uniqueStorage()._numStartUpTips = nil}

  /// DEPRECATED as of version 7.0.
  /// Where to get startup tips from.
  /// e.g. "http://earth.google.com/intl/%1/tips/v43/"
  var startUpTipsURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._startUpTipsURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._startUpTipsURL = newValue}
  }
  /// Returns true if `startUpTipsURL` has been explicitly set.
  var hasStartUpTipsURL: Bool {return _storage._startUpTipsURL != nil}
  /// Clears the value of `startUpTipsURL`. Subsequent reads from it will return its default value.
  mutating func clearStartUpTipsURL() {_uniqueStorage()._startUpTipsURL = nil}

  /// DEPRECATED as of version 7.0.
  /// Same settings for Pro/EC - Pro and EC clients will read these settings.
  var numProStartUpTips: Int32 {
    get {return _storage._numProStartUpTips ?? 0}
    set {_uniqueStorage()._numProStartUpTips = newValue}
  }
  /// Returns true if `numProStartUpTips` has been explicitly set.
  var hasNumProStartUpTips: Bool {return _storage._numProStartUpTips != nil}
  /// Clears the value of `numProStartUpTips`. Subsequent reads from it will return its default value.
  mutating func clearNumProStartUpTips() {_uniqueStorage()._numProStartUpTips = nil}

  /// DEPRECATED as of version 7.0.
  var proStartUpTipsURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._proStartUpTipsURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._proStartUpTipsURL = newValue}
  }
  /// Returns true if `proStartUpTipsURL` has been explicitly set.
  var hasProStartUpTipsURL: Bool {return _storage._proStartUpTipsURL != nil}
  /// Clears the value of `proStartUpTipsURL`. Subsequent reads from it will return its default value.
  mutating func clearProStartUpTipsURL() {_uniqueStorage()._proStartUpTipsURL = nil}

  /// URL from which to load startup tips in Earth 7.0 and higher.  This will be
  /// the same URL for Free and Pro, since that logic is now dealt with on the
  /// server side.
  /// e.g. "http://support.google.com/earth/?p=startup_tip_1"
  var startupTipsIntlURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._startupTipsIntlURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._startupTipsIntlURL = newValue}
  }
  /// Returns true if `startupTipsIntlURL` has been explicitly set.
  var hasStartupTipsIntlURL: Bool {return _storage._startupTipsIntlURL != nil}
  /// Clears the value of `startupTipsIntlURL`. Subsequent reads from it will return its default value.
  mutating func clearStartupTipsIntlURL() {_uniqueStorage()._startupTipsIntlURL = nil}

  /// Url to user guide.
  /// e.g. "http://earth.google.com/intl/%1/userguide/v4/"
  var userGuideIntlURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._userGuideIntlURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._userGuideIntlURL = newValue}
  }
  /// Returns true if `userGuideIntlURL` has been explicitly set.
  var hasUserGuideIntlURL: Bool {return _storage._userGuideIntlURL != nil}
  /// Clears the value of `userGuideIntlURL`. Subsequent reads from it will return its default value.
  mutating func clearUserGuideIntlURL() {_uniqueStorage()._userGuideIntlURL = nil}

  /// Url to support center.
  /// e.g. "http://earth.google.com/support/?hl=%1"
  var supportCenterIntlURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._supportCenterIntlURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._supportCenterIntlURL = newValue}
  }
  /// Returns true if `supportCenterIntlURL` has been explicitly set.
  var hasSupportCenterIntlURL: Bool {return _storage._supportCenterIntlURL != nil}
  /// Clears the value of `supportCenterIntlURL`. Subsequent reads from it will return its default value.
  mutating func clearSupportCenterIntlURL() {_uniqueStorage()._supportCenterIntlURL = nil}

  /// Url to business listings.
  /// e.g. "http://www.google.com/local/add/login?hl=%3&gl=%2"
  var businessListingIntlURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._businessListingIntlURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._businessListingIntlURL = newValue}
  }
  /// Returns true if `businessListingIntlURL` has been explicitly set.
  var hasBusinessListingIntlURL: Bool {return _storage._businessListingIntlURL != nil}
  /// Clears the value of `businessListingIntlURL`. Subsequent reads from it will return its default value.
  mutating func clearBusinessListingIntlURL() {_uniqueStorage()._businessListingIntlURL = nil}

  /// Url to support answer.
  /// e.g. "http://earth.google.com/support/bin/answer.py?answer=%4&hl=%1"
  var supportAnswerIntlURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._supportAnswerIntlURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._supportAnswerIntlURL = newValue}
  }
  /// Returns true if `supportAnswerIntlURL` has been explicitly set.
  var hasSupportAnswerIntlURL: Bool {return _storage._supportAnswerIntlURL != nil}
  /// Clears the value of `supportAnswerIntlURL`. Subsequent reads from it will return its default value.
  mutating func clearSupportAnswerIntlURL() {_uniqueStorage()._supportAnswerIntlURL = nil}

  /// Url to support topics used by certain diagnostic messages.
  /// e.g. "http://earth.google.com/support/bin/topic.py?topic=%4&hl=%1"
  var supportTopicIntlURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._supportTopicIntlURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._supportTopicIntlURL = newValue}
  }
  /// Returns true if `supportTopicIntlURL` has been explicitly set.
  var hasSupportTopicIntlURL: Bool {return _storage._supportTopicIntlURL != nil}
  /// Clears the value of `supportTopicIntlURL`. Subsequent reads from it will return its default value.
  mutating func clearSupportTopicIntlURL() {_uniqueStorage()._supportTopicIntlURL = nil}

  /// Url to support pages.
  /// e.g. "http://earth.google.com/support/bin/request.py?hl=%1"
  var supportRequestIntlURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._supportRequestIntlURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._supportRequestIntlURL = newValue}
  }
  /// Returns true if `supportRequestIntlURL` has been explicitly set.
  var hasSupportRequestIntlURL: Bool {return _storage._supportRequestIntlURL != nil}
  /// Clears the value of `supportRequestIntlURL`. Subsequent reads from it will return its default value.
  mutating func clearSupportRequestIntlURL() {_uniqueStorage()._supportRequestIntlURL = nil}

  /// Location of international page for earth.
  /// e.g. "http://earth.google.com/intl/$[hl]/"
  var earthIntlURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._earthIntlURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._earthIntlURL = newValue}
  }
  /// Returns true if `earthIntlURL` has been explicitly set.
  var hasEarthIntlURL: Bool {return _storage._earthIntlURL != nil}
  /// Clears the value of `earthIntlURL`. Subsequent reads from it will return its default value.
  mutating func clearEarthIntlURL() {_uniqueStorage()._earthIntlURL = nil}

  /// Location of server that accepts uploads from Google Earth.
  /// e.g. "http://earth.google.com/ig/directory?pid=earth&synd=earth&" +
  ///      "hl=$[hl]&gl=%2"
  var addContentURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._addContentURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._addContentURL = newValue}
  }
  /// Returns true if `addContentURL` has been explicitly set.
  var hasAddContentURL: Bool {return _storage._addContentURL != nil}
  /// Clears the value of `addContentURL`. Subsequent reads from it will return its default value.
  mutating func clearAddContentURL() {_uniqueStorage()._addContentURL = nil}

  /// DEPRECATED. There is no longer support for this field. http://b/1605305
  /// URL to show when SketchUp is not installed.
  /// e.g. "http://sketchup.google.com/intl/$[hl]/modeling.html"
  var sketchupNotInstalledURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._sketchupNotInstalledURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._sketchupNotInstalledURL = newValue}
  }
  /// Returns true if `sketchupNotInstalledURL` has been explicitly set.
  var hasSketchupNotInstalledURL: Bool {return _storage._sketchupNotInstalledURL != nil}
  /// Clears the value of `sketchupNotInstalledURL`. Subsequent reads from it will return its default value.
  mutating func clearSketchupNotInstalledURL() {_uniqueStorage()._sketchupNotInstalledURL = nil}

  /// DEPRECATED. There is no longer support for this field. http://b/1605305
  /// URL to show when a SketchUp error occurs.
  /// e.g. "http://sketchup.google.com/intl/$[hl]/gemodelerror.html"
  var sketchupErrorURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._sketchupErrorURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._sketchupErrorURL = newValue}
  }
  /// Returns true if `sketchupErrorURL` has been explicitly set.
  var hasSketchupErrorURL: Bool {return _storage._sketchupErrorURL != nil}
  /// Clears the value of `sketchupErrorURL`. Subsequent reads from it will return its default value.
  mutating func clearSketchupErrorURL() {_uniqueStorage()._sketchupErrorURL = nil}

  /// URL for the terms of service for the free client.
  /// sample value: http://earth.google.com/intl/$[hl]
  var freeLicenseURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._freeLicenseURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._freeLicenseURL = newValue}
  }
  /// Returns true if `freeLicenseURL` has been explicitly set.
  var hasFreeLicenseURL: Bool {return _storage._freeLicenseURL != nil}
  /// Clears the value of `freeLicenseURL`. Subsequent reads from it will return its default value.
  mutating func clearFreeLicenseURL() {_uniqueStorage()._freeLicenseURL = nil}

  /// URL for the license agreement for Google Earth Pro.
  /// sample value: http://earth.google.com/intl/$[hl]
  var proLicenseURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._proLicenseURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._proLicenseURL = newValue}
  }
  /// Returns true if `proLicenseURL` has been explicitly set.
  var hasProLicenseURL: Bool {return _storage._proLicenseURL != nil}
  /// Clears the value of `proLicenseURL`. Subsequent reads from it will return its default value.
  mutating func clearProLicenseURL() {_uniqueStorage()._proLicenseURL = nil}

  /// URL for tutorial page.
  /// If not specified, this URL is built from user_guide_intl_url as
  /// user_guide_intl_url + "tutorials/index.html".
  var tutorialURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._tutorialURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._tutorialURL = newValue}
  }
  /// Returns true if `tutorialURL` has been explicitly set.
  var hasTutorialURL: Bool {return _storage._tutorialURL != nil}
  /// Clears the value of `tutorialURL`. Subsequent reads from it will return its default value.
  mutating func clearTutorialURL() {_uniqueStorage()._tutorialURL = nil}

  /// URL for keyboard shortcuts page.
  /// If not specified, this URL is built from user_guide_intl_url as
  /// user_guide_intl_url + "ug_keyboard.html".
  var keyboardShortcutsURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._keyboardShortcutsURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._keyboardShortcutsURL = newValue}
  }
  /// Returns true if `keyboardShortcutsURL` has been explicitly set.
  var hasKeyboardShortcutsURL: Bool {return _storage._keyboardShortcutsURL != nil}
  /// Clears the value of `keyboardShortcutsURL`. Subsequent reads from it will return its default value.
  mutating func clearKeyboardShortcutsURL() {_uniqueStorage()._keyboardShortcutsURL = nil}

  /// URL for release notes page.
  /// If not specified, this URL is built from support_answer_intl_url,
  /// replacing answer argument with 40901 and appending the application version
  /// as a fragment:
  /// http://earth.google.com/support/bin/answer.py?answer=40901&hl=en#5.1.3533
  var releaseNotesURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._releaseNotesURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._releaseNotesURL = newValue}
  }
  /// Returns true if `releaseNotesURL` has been explicitly set.
  var hasReleaseNotesURL: Bool {return _storage._releaseNotesURL != nil}
  /// Clears the value of `releaseNotesURL`. Subsequent reads from it will return its default value.
  mutating func clearReleaseNotesURL() {_uniqueStorage()._releaseNotesURL = nil}

  /// If true, hides user license key in about dialog. Useful for Pro only,
  /// allows information to not be visible for shared license keys.
  var hideUserData: Bool {
    get {return _storage._hideUserData ?? false}
    set {_uniqueStorage()._hideUserData = newValue}
  }
  /// Returns true if `hideUserData` has been explicitly set.
  var hasHideUserData: Bool {return _storage._hideUserData != nil}
  /// Clears the value of `hideUserData`. Subsequent reads from it will return its default value.
  mutating func clearHideUserData() {_uniqueStorage()._hideUserData = nil}

  /// If true, hides the Google logo. This setting is only honored by entreprise
  /// clients.
  var useGeLogo: Bool {
    get {return _storage._useGeLogo ?? true}
    set {_uniqueStorage()._useGeLogo = newValue}
  }
  /// Returns true if `useGeLogo` has been explicitly set.
  var hasUseGeLogo: Bool {return _storage._useGeLogo != nil}
  /// Clears the value of `useGeLogo`. Subsequent reads from it will return its default value.
  mutating func clearUseGeLogo() {_uniqueStorage()._useGeLogo = nil}

  /// URL to description of diorama layers.
  /// e.g. "http://mw2.google.com/mw-buglight/diorama/descriptions/en/"
  var dioramaDescriptionURLBase: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._dioramaDescriptionURLBase ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._dioramaDescriptionURLBase = newValue}
  }
  /// Returns true if `dioramaDescriptionURLBase` has been explicitly set.
  var hasDioramaDescriptionURLBase: Bool {return _storage._dioramaDescriptionURLBase != nil}
  /// Clears the value of `dioramaDescriptionURLBase`. Subsequent reads from it will return its default value.
  mutating func clearDioramaDescriptionURLBase() {_uniqueStorage()._dioramaDescriptionURLBase = nil}

  /// Color for diorama buildings that do not specify any color. Used for
  /// gray (non-photorealistic) buildings.
  var dioramaDefaultColor: UInt32 {
    get {return _storage._dioramaDefaultColor ?? 4291281607}
    set {_uniqueStorage()._dioramaDefaultColor = newValue}
  }
  /// Returns true if `dioramaDefaultColor` has been explicitly set.
  var hasDioramaDefaultColor: Bool {return _storage._dioramaDefaultColor != nil}
  /// Clears the value of `dioramaDefaultColor`. Subsequent reads from it will return its default value.
  mutating func clearDioramaDefaultColor() {_uniqueStorage()._dioramaDefaultColor = nil}

  /// URL used to fetch Diorama blacklist (ID's of buildings to hide).
  var dioramaBlacklistURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._dioramaBlacklistURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._dioramaBlacklistURL = newValue}
  }
  /// Returns true if `dioramaBlacklistURL` has been explicitly set.
  var hasDioramaBlacklistURL: Bool {return _storage._dioramaBlacklistURL != nil}
  /// Clears the value of `dioramaBlacklistURL`. Subsequent reads from it will return its default value.
  mutating func clearDioramaBlacklistURL() {_uniqueStorage()._dioramaBlacklistURL = nil}

  /// Client-side features that should be altered for this database.
  var clientOptions: Keyhole_Dbroot_ClientOptionsProto {
    get {return _storage._clientOptions ?? Keyhole_Dbroot_ClientOptionsProto()}
    set {_uniqueStorage()._clientOptions = newValue}
  }
  /// Returns true if `clientOptions` has been explicitly set.
  var hasClientOptions: Bool {return _storage._clientOptions != nil}
  /// Clears the value of `clientOptions`. Subsequent reads from it will return its default value.
  mutating func clearClientOptions() {_uniqueStorage()._clientOptions = nil}

  /// Network-related options such as throttle and batched requests
  /// configuration.
  var fetchingOptions: Keyhole_Dbroot_FetchingOptionsProto {
    get {return _storage._fetchingOptions ?? Keyhole_Dbroot_FetchingOptionsProto()}
    set {_uniqueStorage()._fetchingOptions = newValue}
  }
  /// Returns true if `fetchingOptions` has been explicitly set.
  var hasFetchingOptions: Bool {return _storage._fetchingOptions != nil}
  /// Clears the value of `fetchingOptions`. Subsequent reads from it will return its default value.
  mutating func clearFetchingOptions() {_uniqueStorage()._fetchingOptions = nil}

  /// Time-machine related settings
  var timeMachineOptions: Keyhole_Dbroot_TimeMachineOptionsProto {
    get {return _storage._timeMachineOptions ?? Keyhole_Dbroot_TimeMachineOptionsProto()}
    set {_uniqueStorage()._timeMachineOptions = newValue}
  }
  /// Returns true if `timeMachineOptions` has been explicitly set.
  var hasTimeMachineOptions: Bool {return _storage._timeMachineOptions != nil}
  /// Clears the value of `timeMachineOptions`. Subsequent reads from it will return its default value.
  mutating func clearTimeMachineOptions() {_uniqueStorage()._timeMachineOptions = nil}

  /// CSI options for this database.
  var csiOptions: Keyhole_Dbroot_CSIOptionsProto {
    get {return _storage._csiOptions ?? Keyhole_Dbroot_CSIOptionsProto()}
    set {_uniqueStorage()._csiOptions = newValue}
  }
  /// Returns true if `csiOptions` has been explicitly set.
  var hasCsiOptions: Bool {return _storage._csiOptions != nil}
  /// Clears the value of `csiOptions`. Subsequent reads from it will return its default value.
  mutating func clearCsiOptions() {_uniqueStorage()._csiOptions = nil}

  /// List of customized search tabs. If list is empty, use default search tabs.
  var searchTab: [Keyhole_Dbroot_SearchTabProto] {
    get {return _storage._searchTab}
    set {_uniqueStorage()._searchTab = newValue}
  }

  /// List of extra logos to draw on screen.
  var cobrandInfo: [Keyhole_Dbroot_CobrandProto] {
    get {return _storage._cobrandInfo}
    set {_uniqueStorage()._cobrandInfo = newValue}
  }

  /// List of valid databases a client can connect to from this server.
  var validDatabase: [Keyhole_Dbroot_DatabaseDescriptionProto] {
    get {return _storage._validDatabase}
    set {_uniqueStorage()._validDatabase = newValue}
  }

  /// List of client configuration scripts
  var configScript: [Keyhole_Dbroot_ConfigScriptProto] {
    get {return _storage._configScript}
    set {_uniqueStorage()._configScript = newValue}
  }

  /// Url of deauthentication server (for paying customers only)
  var deauthServerURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._deauthServerURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._deauthServerURL = newValue}
  }
  /// Returns true if `deauthServerURL` has been explicitly set.
  var hasDeauthServerURL: Bool {return _storage._deauthServerURL != nil}
  /// Clears the value of `deauthServerURL`. Subsequent reads from it will return its default value.
  mutating func clearDeauthServerURL() {_uniqueStorage()._deauthServerURL = nil}

  /// Swoop parameters - if specified, will affect the amount of swoop when
  /// zooming in and out.
  var swoopParameters: Keyhole_Dbroot_SwoopParamsProto {
    get {return _storage._swoopParameters ?? Keyhole_Dbroot_SwoopParamsProto()}
    set {_uniqueStorage()._swoopParameters = newValue}
  }
  /// Returns true if `swoopParameters` has been explicitly set.
  var hasSwoopParameters: Bool {return _storage._swoopParameters != nil}
  /// Clears the value of `swoopParameters`. Subsequent reads from it will return its default value.
  mutating func clearSwoopParameters() {_uniqueStorage()._swoopParameters = nil}

  /// BBS server parameters. If not specified, default values in the client
  /// will be used.
  var bbsServerInfo: Keyhole_Dbroot_PostingServerProto {
    get {return _storage._bbsServerInfo ?? Keyhole_Dbroot_PostingServerProto()}
    set {_uniqueStorage()._bbsServerInfo = newValue}
  }
  /// Returns true if `bbsServerInfo` has been explicitly set.
  var hasBbsServerInfo: Bool {return _storage._bbsServerInfo != nil}
  /// Clears the value of `bbsServerInfo`. Subsequent reads from it will return its default value.
  mutating func clearBbsServerInfo() {_uniqueStorage()._bbsServerInfo = nil}

  /// Data error server parameters. If not specified, default values in the
  /// client will be used.
  var dataErrorServerInfo: Keyhole_Dbroot_PostingServerProto {
    get {return _storage._dataErrorServerInfo ?? Keyhole_Dbroot_PostingServerProto()}
    set {_uniqueStorage()._dataErrorServerInfo = newValue}
  }
  /// Returns true if `dataErrorServerInfo` has been explicitly set.
  var hasDataErrorServerInfo: Bool {return _storage._dataErrorServerInfo != nil}
  /// Clears the value of `dataErrorServerInfo`. Subsequent reads from it will return its default value.
  mutating func clearDataErrorServerInfo() {_uniqueStorage()._dataErrorServerInfo = nil}

  /// List of other databases accessible from this database.
  var planetaryDatabase: [Keyhole_Dbroot_PlanetaryDatabaseProto] {
    get {return _storage._planetaryDatabase}
    set {_uniqueStorage()._planetaryDatabase = newValue}
  }

  /// Log server configuration
  var logServer: Keyhole_Dbroot_LogServerProto {
    get {return _storage._logServer ?? Keyhole_Dbroot_LogServerProto()}
    set {_uniqueStorage()._logServer = newValue}
  }
  /// Returns true if `logServer` has been explicitly set.
  var hasLogServer: Bool {return _storage._logServer != nil}
  /// Clears the value of `logServer`. Subsequent reads from it will return its default value.
  mutating func clearLogServer() {_uniqueStorage()._logServer = nil}

  var autopiaOptions: Keyhole_Dbroot_AutopiaOptionsProto {
    get {return _storage._autopiaOptions ?? Keyhole_Dbroot_AutopiaOptionsProto()}
    set {_uniqueStorage()._autopiaOptions = newValue}
  }
  /// Returns true if `autopiaOptions` has been explicitly set.
  var hasAutopiaOptions: Bool {return _storage._autopiaOptions != nil}
  /// Clears the value of `autopiaOptions`. Subsequent reads from it will return its default value.
  mutating func clearAutopiaOptions() {_uniqueStorage()._autopiaOptions = nil}

  var searchConfig: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto {
    get {return _storage._searchConfig ?? Keyhole_Dbroot_EndSnippetProto.SearchConfigProto()}
    set {_uniqueStorage()._searchConfig = newValue}
  }
  /// Returns true if `searchConfig` has been explicitly set.
  var hasSearchConfig: Bool {return _storage._searchConfig != nil}
  /// Clears the value of `searchConfig`. Subsequent reads from it will return its default value.
  mutating func clearSearchConfig() {_uniqueStorage()._searchConfig = nil}

  var searchInfo: Keyhole_Dbroot_EndSnippetProto.SearchInfoProto {
    get {return _storage._searchInfo ?? Keyhole_Dbroot_EndSnippetProto.SearchInfoProto()}
    set {_uniqueStorage()._searchInfo = newValue}
  }
  /// Returns true if `searchInfo` has been explicitly set.
  var hasSearchInfo: Bool {return _storage._searchInfo != nil}
  /// Clears the value of `searchInfo`. Subsequent reads from it will return its default value.
  mutating func clearSearchInfo() {_uniqueStorage()._searchInfo = nil}

  /// Terrain elevation service URL. If empty, service will be unavailable.
  /// This should be set to empty for EC clients to disable connection to google
  /// services.
  var elevationServiceBaseURL: String {
    get {return _storage._elevationServiceBaseURL ?? "http://maps.google.com/maps/api/elevation/"}
    set {_uniqueStorage()._elevationServiceBaseURL = newValue}
  }
  /// Returns true if `elevationServiceBaseURL` has been explicitly set.
  var hasElevationServiceBaseURL: Bool {return _storage._elevationServiceBaseURL != nil}
  /// Clears the value of `elevationServiceBaseURL`. Subsequent reads from it will return its default value.
  mutating func clearElevationServiceBaseURL() {_uniqueStorage()._elevationServiceBaseURL = nil}

  /// Length of time in ms to wait before sending query to elevation server.
  /// Can be used to throttle server requests.
  var elevationProfileQueryDelay: Int32 {
    get {return _storage._elevationProfileQueryDelay ?? 500}
    set {_uniqueStorage()._elevationProfileQueryDelay = newValue}
  }
  /// Returns true if `elevationProfileQueryDelay` has been explicitly set.
  var hasElevationProfileQueryDelay: Bool {return _storage._elevationProfileQueryDelay != nil}
  /// Clears the value of `elevationProfileQueryDelay`. Subsequent reads from it will return its default value.
  mutating func clearElevationProfileQueryDelay() {_uniqueStorage()._elevationProfileQueryDelay = nil}

  /// URL of webpage to go to buy Earth Pro License
  var proUpgradeURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._proUpgradeURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._proUpgradeURL = newValue}
  }
  /// Returns true if `proUpgradeURL` has been explicitly set.
  var hasProUpgradeURL: Bool {return _storage._proUpgradeURL != nil}
  /// Clears the value of `proUpgradeURL`. Subsequent reads from it will return its default value.
  mutating func clearProUpgradeURL() {_uniqueStorage()._proUpgradeURL = nil}

  /// URL of webpage to go for Earth Community
  var earthCommunityURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._earthCommunityURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._earthCommunityURL = newValue}
  }
  /// Returns true if `earthCommunityURL` has been explicitly set.
  var hasEarthCommunityURL: Bool {return _storage._earthCommunityURL != nil}
  /// Clears the value of `earthCommunityURL`. Subsequent reads from it will return its default value.
  mutating func clearEarthCommunityURL() {_uniqueStorage()._earthCommunityURL = nil}

  /// URL for Google Maps, for features like "View in Maps". As we no
  /// longer assume that search is only MFE, we need an extra URL
  /// parameter to tell us where to send users who want to view the
  /// current location in Maps. This should be set to empty for EC
  /// clients to disable connection to google services. If nothing is
  /// specified, the client uses "http://maps.google.com/".
  var googleMapsURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._googleMapsURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._googleMapsURL = newValue}
  }
  /// Returns true if `googleMapsURL` has been explicitly set.
  var hasGoogleMapsURL: Bool {return _storage._googleMapsURL != nil}
  /// Clears the value of `googleMapsURL`. Subsequent reads from it will return its default value.
  mutating func clearGoogleMapsURL() {_uniqueStorage()._googleMapsURL = nil}

  /// URL for Sharing in Google+.
  /// e.g. "http://www.gstatic.com/earth/sharing/static/$[hl]/index.html"
  /// If empty, sharing will be unavailable. Introduced in 6.2.
  var sharingURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._sharingURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._sharingURL = newValue}
  }
  /// Returns true if `sharingURL` has been explicitly set.
  var hasSharingURL: Bool {return _storage._sharingURL != nil}
  /// Clears the value of `sharingURL`. Subsequent reads from it will return its default value.
  mutating func clearSharingURL() {_uniqueStorage()._sharingURL = nil}

  /// URL for the privacy policy. Use Google-wide policy, as we don't have
  /// a specific Earth privacy policy.
  /// sample value: http://www.google.com/intl/$[hl]/privacy/
  var privacyPolicyURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._privacyPolicyURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._privacyPolicyURL = newValue}
  }
  /// Returns true if `privacyPolicyURL` has been explicitly set.
  var hasPrivacyPolicyURL: Bool {return _storage._privacyPolicyURL != nil}
  /// Clears the value of `privacyPolicyURL`. Subsequent reads from it will return its default value.
  mutating func clearPrivacyPolicyURL() {_uniqueStorage()._privacyPolicyURL = nil}

  /// If true, the client will check to see if a logged-in user has signed up
  /// for Google+ and grey out the menu item if not.  The standalone
  /// sharebox should eventually handle this for us, at which point this should
  /// be turned off forever.
  var doGplusUserCheck: Bool {
    get {return _storage._doGplusUserCheck ?? false}
    set {_uniqueStorage()._doGplusUserCheck = newValue}
  }
  /// Returns true if `doGplusUserCheck` has been explicitly set.
  var hasDoGplusUserCheck: Bool {return _storage._doGplusUserCheck != nil}
  /// Clears the value of `doGplusUserCheck`. Subsequent reads from it will return its default value.
  mutating func clearDoGplusUserCheck() {_uniqueStorage()._doGplusUserCheck = nil}

  /// Configuration for the filmstrip view.
  var rocktreeDataProto: Keyhole_Dbroot_EndSnippetProto.RockTreeDataProto {
    get {return _storage._rocktreeDataProto ?? Keyhole_Dbroot_EndSnippetProto.RockTreeDataProto()}
    set {_uniqueStorage()._rocktreeDataProto = newValue}
  }
  /// Returns true if `rocktreeDataProto` has been explicitly set.
  var hasRocktreeDataProto: Bool {return _storage._rocktreeDataProto != nil}
  /// Clears the value of `rocktreeDataProto`. Subsequent reads from it will return its default value.
  mutating func clearRocktreeDataProto() {_uniqueStorage()._rocktreeDataProto = nil}

  /// List of filmstrip configs.  All client versions that support the filmstrip
  /// must have a filmstrip config that applies to them.  If more than one
  /// filmstrip config has satisfied requirements, the first one encountered will
  /// be used and the rest will be ignored.
  var filmstripConfig: [Keyhole_Dbroot_EndSnippetProto.FilmstripConfigProto] {
    get {return _storage._filmstripConfig}
    set {_uniqueStorage()._filmstripConfig = newValue}
  }

  /// If true, shows the signin button in the upper right corner.
  var showSigninButton: Bool {
    get {return _storage._showSigninButton ?? false}
    set {_uniqueStorage()._showSigninButton = newValue}
  }
  /// Returns true if `showSigninButton` has been explicitly set.
  var hasShowSigninButton: Bool {return _storage._showSigninButton != nil}
  /// Clears the value of `showSigninButton`. Subsequent reads from it will return its default value.
  mutating func clearShowSigninButton() {_uniqueStorage()._showSigninButton = nil}

  /// The URL for the Google Earth Pro upsell web view in the Measure dialog.
  /// (Only relevant for free clients.)
  var proMeasureUpsellURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._proMeasureUpsellURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._proMeasureUpsellURL = newValue}
  }
  /// Returns true if `proMeasureUpsellURL` has been explicitly set.
  var hasProMeasureUpsellURL: Bool {return _storage._proMeasureUpsellURL != nil}
  /// Clears the value of `proMeasureUpsellURL`. Subsequent reads from it will return its default value.
  mutating func clearProMeasureUpsellURL() {_uniqueStorage()._proMeasureUpsellURL = nil}

  /// The URL for the Google Earth Pro upsell in the Print dialog.
  /// (Only relevant for free clients.)
  var proPrintUpsellURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._proPrintUpsellURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._proPrintUpsellURL = newValue}
  }
  /// Returns true if `proPrintUpsellURL` has been explicitly set.
  var hasProPrintUpsellURL: Bool {return _storage._proPrintUpsellURL != nil}
  /// Clears the value of `proPrintUpsellURL`. Subsequent reads from it will return its default value.
  mutating func clearProPrintUpsellURL() {_uniqueStorage()._proPrintUpsellURL = nil}

  var starDataProto: Keyhole_Dbroot_EndSnippetProto.StarDataProto {
    get {return _storage._starDataProto ?? Keyhole_Dbroot_EndSnippetProto.StarDataProto()}
    set {_uniqueStorage()._starDataProto = newValue}
  }
  /// Returns true if `starDataProto` has been explicitly set.
  var hasStarDataProto: Bool {return _storage._starDataProto != nil}
  /// Clears the value of `starDataProto`. Subsequent reads from it will return its default value.
  mutating func clearStarDataProto() {_uniqueStorage()._starDataProto = nil}

  /// The URL for the gFeedback dialog.  If not specified, the feedback feature
  /// will be disabled.
  var feedbackURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._feedbackURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._feedbackURL = newValue}
  }
  /// Returns true if `feedbackURL` has been explicitly set.
  var hasFeedbackURL: Bool {return _storage._feedbackURL != nil}
  /// Clears the value of `feedbackURL`. Subsequent reads from it will return its default value.
  mutating func clearFeedbackURL() {_uniqueStorage()._feedbackURL = nil}

  /// The URL the client should use to perform an OAuth2 login.
  var oauth2LoginURL: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _storage._oauth2LoginURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_uniqueStorage()._oauth2LoginURL = newValue}
  }
  /// Returns true if `oauth2LoginURL` has been explicitly set.
  var hasOauth2LoginURL: Bool {return _storage._oauth2LoginURL != nil}
  /// Clears the value of `oauth2LoginURL`. Subsequent reads from it will return its default value.
  mutating func clearOauth2LoginURL() {_uniqueStorage()._oauth2LoginURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Search server configuration for Earth 6.1 and higher.  This obsoletes
  /// search_info and the SearchInfoProto message, and also obsoletes search_tab
  /// and SearchTabProto.
  struct SearchConfigProto {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// One or more search servers.  In the consumer Google Earth client, there
    /// is only one of these in the KH database, and it's Google Maps.
    /// Enterprise customers can add extra servers to have them appear in a
    /// tab-like UI above the search field.  For the time being, we will also
    /// convert legacy SearchTabProtos into SearchServers as best we can.
    var searchServer: [Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer] = []

    /// List of onebox services. This field is repeated to support requirements.
    /// The client will select the first onebox service whose requirements allow
    /// it to connect. All others will be ignored.
    var oneboxService: [Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.OneboxServiceProto] = []

    /// URL of a page that will be shown when a KML search is performed.  This
    /// page should have JavaScript that reads the KML from the environment and
    /// renders it as HTML, and also performs onebox and searchlet searches if
    /// applicable.  The URL should be fully encoded, and can use $[hl] and
    /// friends if necessary.
    var kmlSearchURL: Keyhole_Dbroot_StringIdOrValueProto {
      get {return _kmlSearchURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
      set {_kmlSearchURL = newValue}
    }
    /// Returns true if `kmlSearchURL` has been explicitly set.
    var hasKmlSearchURL: Bool {return self._kmlSearchURL != nil}
    /// Clears the value of `kmlSearchURL`. Subsequent reads from it will return its default value.
    mutating func clearKmlSearchURL() {self._kmlSearchURL = nil}

    /// URL of a page that will be shown when KML is rendered in the search
    /// panel.  This page should have JavaScript that reads the KML from the
    /// environment and renders it as HTML, but should NOT perform onebox or
    /// searchlet searches.  The URL should be fully encoded, and can use $[hl]
    /// and friends if necessary.
    var kmlRenderURL: Keyhole_Dbroot_StringIdOrValueProto {
      get {return _kmlRenderURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
      set {_kmlRenderURL = newValue}
    }
    /// Returns true if `kmlRenderURL` has been explicitly set.
    var hasKmlRenderURL: Bool {return self._kmlRenderURL != nil}
    /// Clears the value of `kmlRenderURL`. Subsequent reads from it will return its default value.
    mutating func clearKmlRenderURL() {self._kmlRenderURL = nil}

    /// URL of a page that will be shown when the search history is requested.
    /// This page should have JavaScript that reads the search history from
    /// the client and renders it as HTML.  The URL should be fully encoded,
    /// and can use $[hl] and friends if necessary.
    var searchHistoryURL: Keyhole_Dbroot_StringIdOrValueProto {
      get {return _searchHistoryURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
      set {_searchHistoryURL = newValue}
    }
    /// Returns true if `searchHistoryURL` has been explicitly set.
    var hasSearchHistoryURL: Bool {return self._searchHistoryURL != nil}
    /// Clears the value of `searchHistoryURL`. Subsequent reads from it will return its default value.
    mutating func clearSearchHistoryURL() {self._searchHistoryURL = nil}

    /// URL of a page that will be displayed if a network error or other local
    /// error occurs while performing a search.  This might be an error for a
    /// local geocode while in offline mode, a connection error while trying to
    /// connect to MFE, or some other error where we can't get an error message
    /// from the server.  (Obviously this page should be cached locally, or it's
    /// not terribly useful.)  The URL should be fully encoded, and can use $[hl]
    /// and friends if necessary.
    var errorPageURL: Keyhole_Dbroot_StringIdOrValueProto {
      get {return _errorPageURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
      set {_errorPageURL = newValue}
    }
    /// Returns true if `errorPageURL` has been explicitly set.
    var hasErrorPageURL: Bool {return self._errorPageURL != nil}
    /// Clears the value of `errorPageURL`. Subsequent reads from it will return its default value.
    mutating func clearErrorPageURL() {self._errorPageURL = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Represents a search server that returns XML or KML search results.
    /// There can be any number of these.
    struct SearchServer {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name of the search service.  This will be shown to the user if
      /// (and only if) there is more than one primary_search_server defined.
      /// To avoid bloating the UI, it should be as short as possible.
      var name: Keyhole_Dbroot_StringIdOrValueProto {
        get {return _storage._name ?? Keyhole_Dbroot_StringIdOrValueProto()}
        set {_uniqueStorage()._name = newValue}
      }
      /// Returns true if `name` has been explicitly set.
      var hasName: Bool {return _storage._name != nil}
      /// Clears the value of `name`. Subsequent reads from it will return its default value.
      mutating func clearName() {_uniqueStorage()._name = nil}

      /// The server URL, including protocol, port, and path.
      /// This URL must be fully encoded and use only ASCII characters.
      /// The query parameters will be added automatically, and should not be
      /// specified here.  You can use $[hl] and friends here if necessary, but
      /// the hl and gl parameters will be appended to the query anyway.
      /// Example: http://maps.google.com/local
      var url: Keyhole_Dbroot_StringIdOrValueProto {
        get {return _storage._url ?? Keyhole_Dbroot_StringIdOrValueProto()}
        set {_uniqueStorage()._url = newValue}
      }
      /// Returns true if `url` has been explicitly set.
      var hasURL: Bool {return _storage._url != nil}
      /// Clears the value of `url`. Subsequent reads from it will return its default value.
      mutating func clearURL() {_uniqueStorage()._url = nil}

      /// The format in which this server will return results.
      var type: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.ResultType {
        get {return _storage._type ?? .kml}
        set {_uniqueStorage()._type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      var hasType: Bool {return _storage._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      mutating func clearType() {_uniqueStorage()._type = nil}

      /// If type is RESULT_TYPE_XML, the XML document received from the server
      /// will be fed through the XSLT stylesheet at this (fully encoded,
      /// ASCII-only) URL to generate the HTML that will be shown in the search
      /// results view.  (If type is RESULT_TYPE_KML, the HTML will be generated
      /// using JavaScript.) You can use $[hl] and friends here if necessary.
      var htmlTransformURL: Keyhole_Dbroot_StringIdOrValueProto {
        get {return _storage._htmlTransformURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
        set {_uniqueStorage()._htmlTransformURL = newValue}
      }
      /// Returns true if `htmlTransformURL` has been explicitly set.
      var hasHtmlTransformURL: Bool {return _storage._htmlTransformURL != nil}
      /// Clears the value of `htmlTransformURL`. Subsequent reads from it will return its default value.
      mutating func clearHtmlTransformURL() {_uniqueStorage()._htmlTransformURL = nil}

      /// If type is RESULT_TYPE_XML, the XML document received from the server
      /// will be fed through the XSLT stylesheet at this (fully-encoded,
      /// ASCII-only) URL to generate the KML that will be shown in the 3D view.
      /// (If type is RESULT_TYPE_KML, the KML returned from the server will, of
      /// course, be used directly.) You can use $[hl] and friends here if
      /// necessary.
      var kmlTransformURL: Keyhole_Dbroot_StringIdOrValueProto {
        get {return _storage._kmlTransformURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
        set {_uniqueStorage()._kmlTransformURL = newValue}
      }
      /// Returns true if `kmlTransformURL` has been explicitly set.
      var hasKmlTransformURL: Bool {return _storage._kmlTransformURL != nil}
      /// Clears the value of `kmlTransformURL`. Subsequent reads from it will return its default value.
      mutating func clearKmlTransformURL() {_uniqueStorage()._kmlTransformURL = nil}

      /// If specified, info about the supplemental UI.  If omitted, no
      /// supplemental UI button will be shown.
      var supplementalUi: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.SupplementalUi {
        get {return _storage._supplementalUi ?? Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.SupplementalUi()}
        set {_uniqueStorage()._supplementalUi = newValue}
      }
      /// Returns true if `supplementalUi` has been explicitly set.
      var hasSupplementalUi: Bool {return _storage._supplementalUi != nil}
      /// Clears the value of `supplementalUi`. Subsequent reads from it will return its default value.
      mutating func clearSupplementalUi() {_uniqueStorage()._supplementalUi = nil}

      /// If specified, one or more suggested searches for this server.  Could
      /// be something like "pizza near nyc" or "epsilon eridani".  When the
      /// search UI is shown in the client, one of these suggestions will be
      /// randomly selected and shown beneath the search field.
      var suggestion: [Keyhole_Dbroot_StringIdOrValueProto] {
        get {return _storage._suggestion}
        set {_uniqueStorage()._suggestion = newValue}
      }

      /// List of searchlets that should be queried. Only searchlets that match
      /// the version number of the client will be queried, and only those that
      /// return non-empty results will be displayed.
      var searchlet: [Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.SearchletProto] {
        get {return _storage._searchlet}
        set {_uniqueStorage()._searchlet = newValue}
      }

      /// Optional requirements. The server will only be loaded if requirements
      /// are met. This can be used to selectively exclude a server based on
      /// client capabilities. See definition of RequirementProto for more
      /// details.
      var requirements: Keyhole_Dbroot_RequirementProto {
        get {return _storage._requirements ?? Keyhole_Dbroot_RequirementProto()}
        set {_uniqueStorage()._requirements = newValue}
      }
      /// Returns true if `requirements` has been explicitly set.
      var hasRequirements: Bool {return _storage._requirements != nil}
      /// Clears the value of `requirements`. Subsequent reads from it will return its default value.
      mutating func clearRequirements() {_uniqueStorage()._requirements = nil}

      /// The URL of a server, conforming to the Maps Suggest HTTP API, that
      /// should be used to provide search suggestions for queries to this
      /// server. If not provided, suggestions will be derived from local history
      /// only.
      var suggestServer: Keyhole_Dbroot_StringIdOrValueProto {
        get {return _storage._suggestServer ?? Keyhole_Dbroot_StringIdOrValueProto()}
        set {_uniqueStorage()._suggestServer = newValue}
      }
      /// Returns true if `suggestServer` has been explicitly set.
      var hasSuggestServer: Bool {return _storage._suggestServer != nil}
      /// Clears the value of `suggestServer`. Subsequent reads from it will return its default value.
      mutating func clearSuggestServer() {_uniqueStorage()._suggestServer = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Result format type for search results.
      enum ResultType: SwiftProtobuf.Enum {
        typealias RawValue = Int

        /// The results are pure KML, which should be rendered in the Earth 3D
        /// view directly. The search results listing should be generated from
        /// the KML in whatever way is most appropriate.
        case kml // = 0

        /// The results are an XML document which can be piped through XSLT style
        /// sheets to generate KML for display in the Earth 3D view and HTML for
        /// display in the search results listing.
        case xml // = 1

        init() {
          self = .kml
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .kml
          case 1: self = .xml
          default: return nil
          }
        }

        var rawValue: Int {
          switch self {
          case .kml: return 0
          case .xml: return 1
          }
        }

      }

      /// Information about the supplemental UI, which shows an HTML page that
      /// can be used for rich search entry UI.
      struct SupplementalUi {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// If specified, a button will appear below the search field that, when
        /// clicked, will load this URL in the search panel.  The page can
        /// perform search requests through a JavaScript API.  If omitted, the
        /// button will not be shown. You can use $[hl] and friends here if
        /// necessary.
        var url: Keyhole_Dbroot_StringIdOrValueProto {
          get {return _url ?? Keyhole_Dbroot_StringIdOrValueProto()}
          set {_url = newValue}
        }
        /// Returns true if `url` has been explicitly set.
        var hasURL: Bool {return self._url != nil}
        /// Clears the value of `url`. Subsequent reads from it will return its default value.
        mutating func clearURL() {self._url = nil}

        /// If specified, the label for the supplemental UI.
        var label: Keyhole_Dbroot_StringIdOrValueProto {
          get {return _label ?? Keyhole_Dbroot_StringIdOrValueProto()}
          set {_label = newValue}
        }
        /// Returns true if `label` has been explicitly set.
        var hasLabel: Bool {return self._label != nil}
        /// Clears the value of `label`. Subsequent reads from it will return its default value.
        mutating func clearLabel() {self._label = nil}

        /// The height, in pixels, that will be allocated in the search panel for
        /// the supplemental UI.  This includes the height of the search panel
        /// itself.
        var height: Int32 {
          get {return _height ?? 160}
          set {_height = newValue}
        }
        /// Returns true if `height` has been explicitly set.
        var hasHeight: Bool {return self._height != nil}
        /// Clears the value of `height`. Subsequent reads from it will return its default value.
        mutating func clearHeight() {self._height = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _url: Keyhole_Dbroot_StringIdOrValueProto? = nil
        fileprivate var _label: Keyhole_Dbroot_StringIdOrValueProto? = nil
        fileprivate var _height: Int32? = nil
      }

      /// Searchlet configuration.
      struct SearchletProto {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// The URL of the searchlet service, including protocol, port, and path.
        /// This URL must be fully encoded and use only ASCII characters.
        /// The query parameters will be added automatically, and should not be
        /// specified here. You can, however, use $[hl] and friends here in the
        /// URL path if necessary.
        var url: Keyhole_Dbroot_StringIdOrValueProto {
          get {return _url ?? Keyhole_Dbroot_StringIdOrValueProto()}
          set {_url = newValue}
        }
        /// Returns true if `url` has been explicitly set.
        var hasURL: Bool {return self._url != nil}
        /// Clears the value of `url`. Subsequent reads from it will return its default value.
        mutating func clearURL() {self._url = nil}

        /// The name of this searchlet, which will be shown in its results.
        var name: Keyhole_Dbroot_StringIdOrValueProto {
          get {return _name ?? Keyhole_Dbroot_StringIdOrValueProto()}
          set {_name = newValue}
        }
        /// Returns true if `name` has been explicitly set.
        var hasName: Bool {return self._name != nil}
        /// Clears the value of `name`. Subsequent reads from it will return its default value.
        mutating func clearName() {self._name = nil}

        /// optional requirements - searchlet will only be used if requirements
        /// are met. This can be used to selectively exclude a searchlet based on
        /// client capabilities. See definition of RequirementProto for more
        /// details.
        var requirements: Keyhole_Dbroot_RequirementProto {
          get {return _requirements ?? Keyhole_Dbroot_RequirementProto()}
          set {_requirements = newValue}
        }
        /// Returns true if `requirements` has been explicitly set.
        var hasRequirements: Bool {return self._requirements != nil}
        /// Clears the value of `requirements`. Subsequent reads from it will return its default value.
        mutating func clearRequirements() {self._requirements = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _url: Keyhole_Dbroot_StringIdOrValueProto? = nil
        fileprivate var _name: Keyhole_Dbroot_StringIdOrValueProto? = nil
        fileprivate var _requirements: Keyhole_Dbroot_RequirementProto? = nil
      }

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    /// Configuration for the onebox service.
    struct OneboxServiceProto {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The URL of the onebox service, including protocol, port, and path.
      /// This URL must be fully encoded and use only ASCII characters.  It can
      /// use $[hl] and friends here if necessary.
      var serviceURL: Keyhole_Dbroot_StringIdOrValueProto {
        get {return _serviceURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
        set {_serviceURL = newValue}
      }
      /// Returns true if `serviceURL` has been explicitly set.
      var hasServiceURL: Bool {return self._serviceURL != nil}
      /// Clears the value of `serviceURL`. Subsequent reads from it will return its default value.
      mutating func clearServiceURL() {self._serviceURL = nil}

      /// optional requirements - onebox service will only be used if
      /// requirements are met. This can be used to selectively choose a onebox
      /// service based on client capabilities. See definition of
      /// RequirementProto for more details.
      var requirements: Keyhole_Dbroot_RequirementProto {
        get {return _requirements ?? Keyhole_Dbroot_RequirementProto()}
        set {_requirements = newValue}
      }
      /// Returns true if `requirements` has been explicitly set.
      var hasRequirements: Bool {return self._requirements != nil}
      /// Clears the value of `requirements`. Subsequent reads from it will return its default value.
      mutating func clearRequirements() {self._requirements = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _serviceURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
      fileprivate var _requirements: Keyhole_Dbroot_RequirementProto? = nil
    }

    init() {}

    fileprivate var _kmlSearchURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    fileprivate var _kmlRenderURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    fileprivate var _searchHistoryURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    fileprivate var _errorPageURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
  }

  /// Search server configuration.  Deprecated and unused since Earth 6.1.
  struct SearchInfoProto {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Default search server (MFE) URL.
    /// Note that this can be reconfigured on a per-country basis with
    /// MfeDomainFeaturesProto.
    var defaultURL: String {
      get {return _defaultURL ?? "http://maps.google.com/maps"}
      set {_defaultURL = newValue}
    }
    /// Returns true if `defaultURL` has been explicitly set.
    var hasDefaultURL: Bool {return self._defaultURL != nil}
    /// Clears the value of `defaultURL`. Subsequent reads from it will return its default value.
    mutating func clearDefaultURL() {self._defaultURL = nil}

    /// Query parameter to use for queries on maps server.
    var geocodeParam: String {
      get {return _geocodeParam ?? "q"}
      set {_geocodeParam = newValue}
    }
    /// Returns true if `geocodeParam` has been explicitly set.
    var hasGeocodeParam: Bool {return self._geocodeParam != nil}
    /// Clears the value of `geocodeParam`. Subsequent reads from it will return its default value.
    mutating func clearGeocodeParam() {self._geocodeParam = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _defaultURL: String? = nil
    fileprivate var _geocodeParam: String? = nil
  }

  /// Data for the client to connect to a server for RockTree (EOS3D) data.
  struct RockTreeDataProto {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var url: Keyhole_Dbroot_StringIdOrValueProto {
      get {return _url ?? Keyhole_Dbroot_StringIdOrValueProto()}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    var hasURL: Bool {return self._url != nil}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    mutating func clearURL() {self._url = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _url: Keyhole_Dbroot_StringIdOrValueProto? = nil
  }

  struct FilmstripConfigProto {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Client requirements for using the templates listed below.
    var requirements: Keyhole_Dbroot_RequirementProto {
      get {return _storage._requirements ?? Keyhole_Dbroot_RequirementProto()}
      set {_uniqueStorage()._requirements = newValue}
    }
    /// Returns true if `requirements` has been explicitly set.
    var hasRequirements: Bool {return _storage._requirements != nil}
    /// Clears the value of `requirements`. Subsequent reads from it will return its default value.
    mutating func clearRequirements() {_uniqueStorage()._requirements = nil}

    /// Template for the alleycat server URL that should be queried for the
    /// filmstrip items at a given viewport.
    ///
    /// Template can be different depending on the user agent or client version.
    /// For example, Linux -7.0 can use default config with only Earth Tours,
    /// and Android 7.2- can use new URL with panoramas. Add new FilmstripConfig
    /// message to the snippet along with user agent / version requirement to
    /// use non-default URL.
    ///
    /// Android example: go/filmstripdbrootconfig
    ///
    /// Server API: go/getbestview
    ///
    /// For this template, the following properties apply:
    ///   - The URL *must* be absolute.
    ///   - $[max] will be replaced with the maximum number of results (specified
    ///         by the client implementation).
    ///   - $[focus] will be replaced with the current focus point as a comma-
    ///         separated lat-lon pair.
    ///   - $[polygon] will be replaced with a comma-separated list of
    ///         comma-separated lat-lon pairs representing the viewport.
    ///
    /// Examples:
    ///     Current API:
    ///     http://cbk0.google.com/cbk?output=polygon&it=8:$[max]
    ///         &polygon=$[polygon]&ll=$[focus]&rank=closest
    ///
    ///     Proposed example future API:
    ///      1. 40% of Earth Tours, 40% of UGC Panos, 20% of Art Project
    ///      http://cbk1.google.com/cbk?output=polygon&cb_client=earth
    ///        &it=8:$[max:0.4],11:$[max:0.4],4:$[max:0.2]&polygon=$[polygon]
    ///        &ll=$[focus]&rank=centered
    ///
    ///      2. Best $[max] items in view of either Earth Tour or UGC Pano type
    ///         (types are crossranked, number of each type is variable).
    ///      http://cbk1.google.com/cbk?output=polygon&cb_client=earth
    ///        &it=8:1,11:1&polygon=$[polygon]
    ///        &ll=$[focus]&rank=centered&rs=$[max]
    var alleycatURLTemplate: Keyhole_Dbroot_StringIdOrValueProto {
      get {return _storage._alleycatURLTemplate ?? Keyhole_Dbroot_StringIdOrValueProto()}
      set {_uniqueStorage()._alleycatURLTemplate = newValue}
    }
    /// Returns true if `alleycatURLTemplate` has been explicitly set.
    var hasAlleycatURLTemplate: Bool {return _storage._alleycatURLTemplate != nil}
    /// Clears the value of `alleycatURLTemplate`. Subsequent reads from it will return its default value.
    mutating func clearAlleycatURLTemplate() {_uniqueStorage()._alleycatURLTemplate = nil}

    /// Secondary alleycat server URL template.  This will be used during
    /// viewport fallback.
    /// For this template, the following properties apply:
    ///   - The URL *must* be absolute.
    ///   - $[max] will be replaced with the maximum number of results (specified
    ///         by the client implementation).
    ///   - $[focus] will be replaced with the current focus point as a comma-
    ///         separated lat-lon pair.
    ///
    /// Examples:
    ///     Current API:
    ///     http://cbk0.google.com/cbk?output=polygon&it=8:$[max]
    ///         &radius=120000&rank=closest
    ///
    ///     Proposed future API:
    ///     http://cbk0.google.com/cbk?output=polygon&it=8:5,14:100&mix=1
    ///         &max=$[max]&radius=120000&rank=closest
    var fallbackAlleycatURLTemplate: Keyhole_Dbroot_StringIdOrValueProto {
      get {return _storage._fallbackAlleycatURLTemplate ?? Keyhole_Dbroot_StringIdOrValueProto()}
      set {_uniqueStorage()._fallbackAlleycatURLTemplate = newValue}
    }
    /// Returns true if `fallbackAlleycatURLTemplate` has been explicitly set.
    var hasFallbackAlleycatURLTemplate: Bool {return _storage._fallbackAlleycatURLTemplate != nil}
    /// Clears the value of `fallbackAlleycatURLTemplate`. Subsequent reads from it will return its default value.
    mutating func clearFallbackAlleycatURLTemplate() {_uniqueStorage()._fallbackAlleycatURLTemplate = nil}

    /// Template for the URL at which the metadata for a given ID can be found.
    /// Ex: http://mw1.google.com/mw-earth-vectordb/tourguide/json/$[id].json
    /// DEPRECATED. Used by clients that get config from default dbroot snippet.
    /// See AlleycatImageryTypeProto imagery_types below for recommended format.
    var metadataURLTemplate: Keyhole_Dbroot_StringIdOrValueProto {
      get {return _storage._metadataURLTemplate ?? Keyhole_Dbroot_StringIdOrValueProto()}
      set {_uniqueStorage()._metadataURLTemplate = newValue}
    }
    /// Returns true if `metadataURLTemplate` has been explicitly set.
    var hasMetadataURLTemplate: Bool {return _storage._metadataURLTemplate != nil}
    /// Clears the value of `metadataURLTemplate`. Subsequent reads from it will return its default value.
    mutating func clearMetadataURLTemplate() {_uniqueStorage()._metadataURLTemplate = nil}

    /// Template for the URL at which the thumbnail for a given ID can be found.
    /// Ex: http://mw1.google.com/mw-earth-vectordb/tourguide/thumbnails/$[id].jpg
    /// DEPRECATED. Used by clients that get config from default dbroot snippet.
    /// See AlleycatImageryTypeProto imagery_types below for recommended format.
    var thumbnailURLTemplate: Keyhole_Dbroot_StringIdOrValueProto {
      get {return _storage._thumbnailURLTemplate ?? Keyhole_Dbroot_StringIdOrValueProto()}
      set {_uniqueStorage()._thumbnailURLTemplate = newValue}
    }
    /// Returns true if `thumbnailURLTemplate` has been explicitly set.
    var hasThumbnailURLTemplate: Bool {return _storage._thumbnailURLTemplate != nil}
    /// Clears the value of `thumbnailURLTemplate`. Subsequent reads from it will return its default value.
    mutating func clearThumbnailURLTemplate() {_uniqueStorage()._thumbnailURLTemplate = nil}

    /// Template for the URL at which the KML for a given ID can be found.
    /// Ex: http://mw1.google.com/mw-earth-vectordb/tourguide/tours/$[id]_$[hl].kml
    /// DEPRECATED. Used by clients that get config from default dbroot snippet.
    /// See AlleycatImageryTypeProto imagery_types below for recommended format.
    var kmlURLTemplate: Keyhole_Dbroot_StringIdOrValueProto {
      get {return _storage._kmlURLTemplate ?? Keyhole_Dbroot_StringIdOrValueProto()}
      set {_uniqueStorage()._kmlURLTemplate = newValue}
    }
    /// Returns true if `kmlURLTemplate` has been explicitly set.
    var hasKmlURLTemplate: Bool {return _storage._kmlURLTemplate != nil}
    /// Clears the value of `kmlURLTemplate`. Subsequent reads from it will return its default value.
    mutating func clearKmlURLTemplate() {_uniqueStorage()._kmlURLTemplate = nil}

    /// URL at which the featured tours JSON file can be found.
    /// Ex: http://mw1.google.com/mw-earth-vectordb/tourguide/featured.json
    /// Note: Since this is not a template, $[id] will not be replaced by
    /// anything, but $[hl] will still be resolved as above.
    var featuredToursURL: Keyhole_Dbroot_StringIdOrValueProto {
      get {return _storage._featuredToursURL ?? Keyhole_Dbroot_StringIdOrValueProto()}
      set {_uniqueStorage()._featuredToursURL = newValue}
    }
    /// Returns true if `featuredToursURL` has been explicitly set.
    var hasFeaturedToursURL: Bool {return _storage._featuredToursURL != nil}
    /// Clears the value of `featuredToursURL`. Subsequent reads from it will return its default value.
    mutating func clearFeaturedToursURL() {_uniqueStorage()._featuredToursURL = nil}

    /// Whether to perform client-side viewport fallback.
    var enableViewportFallback: Bool {
      get {return _storage._enableViewportFallback ?? false}
      set {_uniqueStorage()._enableViewportFallback = newValue}
    }
    /// Returns true if `enableViewportFallback` has been explicitly set.
    var hasEnableViewportFallback: Bool {return _storage._enableViewportFallback != nil}
    /// Clears the value of `enableViewportFallback`. Subsequent reads from it will return its default value.
    mutating func clearEnableViewportFallback() {_uniqueStorage()._enableViewportFallback = nil}

    /// DEPRECATED. Unused. Specify fallback_alleycat_url_template instead.
    var viewportFallbackDistance: UInt32 {
      get {return _storage._viewportFallbackDistance ?? 0}
      set {_uniqueStorage()._viewportFallbackDistance = newValue}
    }
    /// Returns true if `viewportFallbackDistance` has been explicitly set.
    var hasViewportFallbackDistance: Bool {return _storage._viewportFallbackDistance != nil}
    /// Clears the value of `viewportFallbackDistance`. Subsequent reads from it will return its default value.
    mutating func clearViewportFallbackDistance() {_uniqueStorage()._viewportFallbackDistance = nil}

    /// See comments and example above.
    var imageryType: [Keyhole_Dbroot_EndSnippetProto.FilmstripConfigProto.AlleycatImageryTypeProto] {
      get {return _storage._imageryType}
      set {_uniqueStorage()._imageryType = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Each alleycat imagery type supported by Earth filmstrip needs to be
    /// described. Some imagery types might have one or more empty URL
    /// templates, meaning no additional request needs to be made to handle
    /// image of that type.
    ///
    /// Example use: go/filmstripdbrootconfig
    struct AlleycatImageryTypeProto {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Alleycat Imagery type id. E.g. 8 for Earth Tour.
      /// Reference: go/bestview/imagery-types
      var imageryTypeID: Int32 {
        get {return _imageryTypeID ?? 0}
        set {_imageryTypeID = newValue}
      }
      /// Returns true if `imageryTypeID` has been explicitly set.
      var hasImageryTypeID: Bool {return self._imageryTypeID != nil}
      /// Clears the value of `imageryTypeID`. Subsequent reads from it will return its default value.
      mutating func clearImageryTypeID() {self._imageryTypeID = nil}

      /// Imagery Type label. E.g. "Earth Tour". Untranslated - don't show to
      /// user. Currently only used for developers' information.
      var imageryTypeLabel: String {
        get {return _imageryTypeLabel ?? String()}
        set {_imageryTypeLabel = newValue}
      }
      /// Returns true if `imageryTypeLabel` has been explicitly set.
      var hasImageryTypeLabel: Bool {return self._imageryTypeLabel != nil}
      /// Clears the value of `imageryTypeLabel`. Subsequent reads from it will return its default value.
      mutating func clearImageryTypeLabel() {self._imageryTypeLabel = nil}

      /// URL template for fetching additional metadata. "" if not needed.
      var metadataURLTemplate: Keyhole_Dbroot_StringIdOrValueProto {
        get {return _metadataURLTemplate ?? Keyhole_Dbroot_StringIdOrValueProto()}
        set {_metadataURLTemplate = newValue}
      }
      /// Returns true if `metadataURLTemplate` has been explicitly set.
      var hasMetadataURLTemplate: Bool {return self._metadataURLTemplate != nil}
      /// Clears the value of `metadataURLTemplate`. Subsequent reads from it will return its default value.
      mutating func clearMetadataURLTemplate() {self._metadataURLTemplate = nil}

      /// URL template for fetching thumbnail. "" if not needed.
      var thumbnailURLTemplate: Keyhole_Dbroot_StringIdOrValueProto {
        get {return _thumbnailURLTemplate ?? Keyhole_Dbroot_StringIdOrValueProto()}
        set {_thumbnailURLTemplate = newValue}
      }
      /// Returns true if `thumbnailURLTemplate` has been explicitly set.
      var hasThumbnailURLTemplate: Bool {return self._thumbnailURLTemplate != nil}
      /// Clears the value of `thumbnailURLTemplate`. Subsequent reads from it will return its default value.
      mutating func clearThumbnailURLTemplate() {self._thumbnailURLTemplate = nil}

      /// URL template for fetching KML. "" if not needed
      /// (e.g. if KML is generated on client side).
      var kmlURLTemplate: Keyhole_Dbroot_StringIdOrValueProto {
        get {return _kmlURLTemplate ?? Keyhole_Dbroot_StringIdOrValueProto()}
        set {_kmlURLTemplate = newValue}
      }
      /// Returns true if `kmlURLTemplate` has been explicitly set.
      var hasKmlURLTemplate: Bool {return self._kmlURLTemplate != nil}
      /// Clears the value of `kmlURLTemplate`. Subsequent reads from it will return its default value.
      mutating func clearKmlURLTemplate() {self._kmlURLTemplate = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _imageryTypeID: Int32? = nil
      fileprivate var _imageryTypeLabel: String? = nil
      fileprivate var _metadataURLTemplate: Keyhole_Dbroot_StringIdOrValueProto? = nil
      fileprivate var _thumbnailURLTemplate: Keyhole_Dbroot_StringIdOrValueProto? = nil
      fileprivate var _kmlURLTemplate: Keyhole_Dbroot_StringIdOrValueProto? = nil
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Data for the client to connect to a server for star data.
  struct StarDataProto {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var url: Keyhole_Dbroot_StringIdOrValueProto {
      get {return _url ?? Keyhole_Dbroot_StringIdOrValueProto()}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    var hasURL: Bool {return self._url != nil}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    mutating func clearURL() {self._url = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _url: Keyhole_Dbroot_StringIdOrValueProto? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.ResultType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Message that references another portion of dbroot that should be fetched
/// and merged with this dbroot. This is the main feature of DbRootProto which
/// allows DbRoot to be split into multiple, hierarchical dbroots that the client
/// will fetch and merge together.
struct Keyhole_Dbroot_DbRootRefProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Location of other dbroot. URL can be relative (to this document) or
  /// absolute. URL must be resolved by client. Do not forget that the client
  /// fetching dbroot objects *always* appends query parameters identifying its
  /// language and platform.
  var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  /// Flag that tells whether or not this object must be downloaded
  /// before showing the planet. By default only the first object is
  /// critical (the client cannot show the planet before knowing what the
  /// database contains).
  /// Note: non-critical objects cannot reference critical objects (these will
  /// not be counted as "critical", because the client has no way to know that a
  /// non-critical object that it contains any critical object before fetching
  /// and parsing it.
  var isCritical: Bool {
    get {return _isCritical ?? false}
    set {_isCritical = newValue}
  }
  /// Returns true if `isCritical` has been explicitly set.
  var hasIsCritical: Bool {return self._isCritical != nil}
  /// Clears the value of `isCritical`. Subsequent reads from it will return its default value.
  mutating func clearIsCritical() {self._isCritical = nil}

  /// optional requirements - object will only be downloaded if requirements
  /// are met. This can be used to selectively exclude an object based on client
  /// capabilities. See definition of RequirementProto for more details.
  var requirements: Keyhole_Dbroot_RequirementProto {
    get {return _requirements ?? Keyhole_Dbroot_RequirementProto()}
    set {_requirements = newValue}
  }
  /// Returns true if `requirements` has been explicitly set.
  var hasRequirements: Bool {return self._requirements != nil}
  /// Clears the value of `requirements`. Subsequent reads from it will return its default value.
  mutating func clearRequirements() {self._requirements = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _url: String? = nil
  fileprivate var _isCritical: Bool? = nil
  fileprivate var _requirements: Keyhole_Dbroot_RequirementProto? = nil
}

struct Keyhole_Dbroot_DatabaseVersionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number that indicates the "version" of the quad-tree - used to be
  /// 'qtDataVersion' in the flatfile protocol (in the preamble of dbroot), and
  /// is also known as "epoch".
  var quadtreeVersion: UInt32 {
    get {return _quadtreeVersion ?? 0}
    set {_quadtreeVersion = newValue}
  }
  /// Returns true if `quadtreeVersion` has been explicitly set.
  var hasQuadtreeVersion: Bool {return self._quadtreeVersion != nil}
  /// Clears the value of `quadtreeVersion`. Subsequent reads from it will return its default value.
  mutating func clearQuadtreeVersion() {self._quadtreeVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _quadtreeVersion: UInt32? = nil
}

/// The central part of DbRoot, which aggregates information about the database.
/// Next id: 17
struct Keyhole_Dbroot_DbRootProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the database that should appear as layer name in the layers panel.
  var databaseName: Keyhole_Dbroot_StringIdOrValueProto {
    get {return _databaseName ?? Keyhole_Dbroot_StringIdOrValueProto()}
    set {_databaseName = newValue}
  }
  /// Returns true if `databaseName` has been explicitly set.
  var hasDatabaseName: Bool {return self._databaseName != nil}
  /// Clears the value of `databaseName`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseName() {self._databaseName = nil}

  /// Describes whether this database contains imagery.
  var imageryPresent: Bool {
    get {return _imageryPresent ?? true}
    set {_imageryPresent = newValue}
  }
  /// Returns true if `imageryPresent` has been explicitly set.
  var hasImageryPresent: Bool {return self._imageryPresent != nil}
  /// Clears the value of `imageryPresent`. Subsequent reads from it will return its default value.
  mutating func clearImageryPresent() {self._imageryPresent = nil}

  /// True if the imagery packets are going to be served as protocol buffers.
  var protoImagery: Bool {
    get {return _protoImagery ?? false}
    set {_protoImagery = newValue}
  }
  /// Returns true if `protoImagery` has been explicitly set.
  var hasProtoImagery: Bool {return self._protoImagery != nil}
  /// Clears the value of `protoImagery`. Subsequent reads from it will return its default value.
  mutating func clearProtoImagery() {self._protoImagery = nil}

  /// Describes whether this database contains terrain.
  var terrainPresent: Bool {
    get {return _terrainPresent ?? false}
    set {_terrainPresent = newValue}
  }
  /// Returns true if `terrainPresent` has been explicitly set.
  var hasTerrainPresent: Bool {return self._terrainPresent != nil}
  /// Clears the value of `terrainPresent`. Subsequent reads from it will return its default value.
  mutating func clearTerrainPresent() {self._terrainPresent = nil}

  /// Stores information about the data provider and copyright information.
  var providerInfo: [Keyhole_Dbroot_ProviderInfoProto] = []

  /// List of "layers" that are available in database.
  var nestedFeature: [Keyhole_Dbroot_NestedFeatureProto] = []

  /// List of styles referenced by style maps.
  var styleAttribute: [Keyhole_Dbroot_StyleAttributeProto] = []

  /// List of style maps used by layers.
  var styleMap: [Keyhole_Dbroot_StyleMapProto] = []

  /// Miscellaneous configuration options for database.
  var endSnippet: Keyhole_Dbroot_EndSnippetProto {
    get {return _endSnippet ?? Keyhole_Dbroot_EndSnippetProto()}
    set {_endSnippet = newValue}
  }
  /// Returns true if `endSnippet` has been explicitly set.
  var hasEndSnippet: Bool {return self._endSnippet != nil}
  /// Clears the value of `endSnippet`. Subsequent reads from it will return its default value.
  mutating func clearEndSnippet() {self._endSnippet = nil}

  /// List of id/string value pairs - this constitutes the translation table for
  /// all messages used in dbroot.
  var translationEntry: [Keyhole_Dbroot_StringEntryProto] = []

  /// The language associated with this DbRoot.  This is a language
  /// code compatible with the Google III language API, meaning that it
  /// should be treated as an opaque identifier that can denote
  /// language, script, country, and a bunch of other stuff.
  var language: String {
    get {return _language ?? "en"}
    set {_language = newValue}
  }
  /// Returns true if `language` has been explicitly set.
  var hasLanguage: Bool {return self._language != nil}
  /// Clears the value of `language`. Subsequent reads from it will return its default value.
  mutating func clearLanguage() {self._language = nil}

  /// The dbroots use a versioning system. Newer clients will look for
  /// version 6. If they don't find it they will request version 5 and so on.
  /// Currently the only dbroot version supported is v5.
  var version: Int32 {
    get {return _version ?? 5}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  /// List of objects that should be downloaded to make this dbroot complete.
  /// For instance, the translation table for all string IDs used in this dbroot
  /// might be located in another dbroot object. It is a good idea to group
  /// together information that does not change across languages or platforms and
  /// build different dbroots per platform or language that clients will request
  /// depending on their configuration.
  var dbrootReference: [Keyhole_Dbroot_DbRootRefProto] = []

  /// This should be set in main part to let the client know the current quadtree
  /// version number. However, it's legal to build dbroot parts without this
  /// message - the epoch of the database is typically known late in the
  /// production pipeline.
  var databaseVersion: Keyhole_Dbroot_DatabaseVersionProto {
    get {return _databaseVersion ?? Keyhole_Dbroot_DatabaseVersionProto()}
    set {_databaseVersion = newValue}
  }
  /// Returns true if `databaseVersion` has been explicitly set.
  var hasDatabaseVersion: Bool {return self._databaseVersion != nil}
  /// Clears the value of `databaseVersion`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseVersion() {self._databaseVersion = nil}

  /// Indicates how often this should be refreshed from server. Value is
  /// interpreted in seconds. 0 turns off refreshing.
  /// Supported as of Earth 7.1 for side databases only.
  var refreshTimeout: Int32 {
    get {return _refreshTimeout ?? 0}
    set {_refreshTimeout = newValue}
  }
  /// Returns true if `refreshTimeout` has been explicitly set.
  var hasRefreshTimeout: Bool {return self._refreshTimeout != nil}
  /// Clears the value of `refreshTimeout`. Subsequent reads from it will return its default value.
  mutating func clearRefreshTimeout() {self._refreshTimeout = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _databaseName: Keyhole_Dbroot_StringIdOrValueProto? = nil
  fileprivate var _imageryPresent: Bool? = nil
  fileprivate var _protoImagery: Bool? = nil
  fileprivate var _terrainPresent: Bool? = nil
  fileprivate var _endSnippet: Keyhole_Dbroot_EndSnippetProto? = nil
  fileprivate var _language: String? = nil
  fileprivate var _version: Int32? = nil
  fileprivate var _databaseVersion: Keyhole_Dbroot_DatabaseVersionProto? = nil
  fileprivate var _refreshTimeout: Int32? = nil
}

/// Message that contains an encrypted and compressed version of dbroot.
struct Keyhole_Dbroot_EncryptedDbRootProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var encryptionType: Keyhole_Dbroot_EncryptedDbRootProto.EncryptionType {
    get {return _encryptionType ?? .encryptionXor}
    set {_encryptionType = newValue}
  }
  /// Returns true if `encryptionType` has been explicitly set.
  var hasEncryptionType: Bool {return self._encryptionType != nil}
  /// Clears the value of `encryptionType`. Subsequent reads from it will return its default value.
  mutating func clearEncryptionType() {self._encryptionType = nil}

  /// Depending on encryption type, this can contain information on the key.
  var encryptionData: Data {
    get {return _encryptionData ?? Data()}
    set {_encryptionData = newValue}
  }
  /// Returns true if `encryptionData` has been explicitly set.
  var hasEncryptionData: Bool {return self._encryptionData != nil}
  /// Clears the value of `encryptionData`. Subsequent reads from it will return its default value.
  mutating func clearEncryptionData() {self._encryptionData = nil}

  /// Compressed and encrypted bytes of dbroot data. Once decompressed and
  /// decrypted, the bytes can be parsed as a DbRootProto message.
  var dbrootData: Data {
    get {return _dbrootData ?? Data()}
    set {_dbrootData = newValue}
  }
  /// Returns true if `dbrootData` has been explicitly set.
  var hasDbrootData: Bool {return self._dbrootData != nil}
  /// Clears the value of `dbrootData`. Subsequent reads from it will return its default value.
  mutating func clearDbrootData() {self._dbrootData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// List of all known encryption types for the encrypted buffer.
  enum EncryptionType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Modified XOR algorithm (used in flatfile protocol).
    case encryptionXor // = 0

    init() {
      self = .encryptionXor
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .encryptionXor
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .encryptionXor: return 0
      }
    }

  }

  init() {}

  fileprivate var _encryptionType: Keyhole_Dbroot_EncryptedDbRootProto.EncryptionType? = nil
  fileprivate var _encryptionData: Data? = nil
  fileprivate var _dbrootData: Data? = nil
}

#if swift(>=4.2)

extension Keyhole_Dbroot_EncryptedDbRootProto.EncryptionType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Keyhole_Dbroot_StringEntryProto: @unchecked Sendable {}
extension Keyhole_Dbroot_StringIdOrValueProto: @unchecked Sendable {}
extension Keyhole_Dbroot_PlanetModelProto: @unchecked Sendable {}
extension Keyhole_Dbroot_ProviderInfoProto: @unchecked Sendable {}
extension Keyhole_Dbroot_PopUpProto: @unchecked Sendable {}
extension Keyhole_Dbroot_StyleAttributeProto: @unchecked Sendable {}
extension Keyhole_Dbroot_StyleMapProto: @unchecked Sendable {}
extension Keyhole_Dbroot_ZoomRangeProto: @unchecked Sendable {}
extension Keyhole_Dbroot_DrawFlagProto: @unchecked Sendable {}
extension Keyhole_Dbroot_DrawFlagProto.DrawFlagType: @unchecked Sendable {}
extension Keyhole_Dbroot_LayerProto: @unchecked Sendable {}
extension Keyhole_Dbroot_FolderProto: @unchecked Sendable {}
extension Keyhole_Dbroot_RequirementProto: @unchecked Sendable {}
extension Keyhole_Dbroot_LookAtProto: @unchecked Sendable {}
extension Keyhole_Dbroot_NestedFeatureProto: @unchecked Sendable {}
extension Keyhole_Dbroot_NestedFeatureProto.FeatureType: @unchecked Sendable {}
extension Keyhole_Dbroot_MfeDomainFeaturesProto: @unchecked Sendable {}
extension Keyhole_Dbroot_MfeDomainFeaturesProto.SupportedFeature: @unchecked Sendable {}
extension Keyhole_Dbroot_ClientOptionsProto: @unchecked Sendable {}
extension Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions: @unchecked Sendable {}
extension Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions.WeatherMapping: @unchecked Sendable {}
extension Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions.WeatherMapping.WeatherType: @unchecked Sendable {}
extension Keyhole_Dbroot_ClientOptionsProto.CaptureOptions: @unchecked Sendable {}
extension Keyhole_Dbroot_ClientOptionsProto.MapsOptions: @unchecked Sendable {}
extension Keyhole_Dbroot_FetchingOptionsProto: @unchecked Sendable {}
extension Keyhole_Dbroot_TimeMachineOptionsProto: @unchecked Sendable {}
extension Keyhole_Dbroot_AutopiaOptionsProto: @unchecked Sendable {}
extension Keyhole_Dbroot_CSIOptionsProto: @unchecked Sendable {}
extension Keyhole_Dbroot_SearchTabProto: @unchecked Sendable {}
extension Keyhole_Dbroot_SearchTabProto.InputBoxInfo: @unchecked Sendable {}
extension Keyhole_Dbroot_CobrandProto: @unchecked Sendable {}
extension Keyhole_Dbroot_CobrandProto.TiePoint: @unchecked Sendable {}
extension Keyhole_Dbroot_CobrandProto.Coord: @unchecked Sendable {}
extension Keyhole_Dbroot_DatabaseDescriptionProto: @unchecked Sendable {}
extension Keyhole_Dbroot_ConfigScriptProto: @unchecked Sendable {}
extension Keyhole_Dbroot_SwoopParamsProto: @unchecked Sendable {}
extension Keyhole_Dbroot_PostingServerProto: @unchecked Sendable {}
extension Keyhole_Dbroot_PlanetaryDatabaseProto: @unchecked Sendable {}
extension Keyhole_Dbroot_LogServerProto: @unchecked Sendable {}
extension Keyhole_Dbroot_EndSnippetProto: @unchecked Sendable {}
extension Keyhole_Dbroot_EndSnippetProto.SearchConfigProto: @unchecked Sendable {}
extension Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer: @unchecked Sendable {}
extension Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.ResultType: @unchecked Sendable {}
extension Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.SupplementalUi: @unchecked Sendable {}
extension Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.SearchletProto: @unchecked Sendable {}
extension Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.OneboxServiceProto: @unchecked Sendable {}
extension Keyhole_Dbroot_EndSnippetProto.SearchInfoProto: @unchecked Sendable {}
extension Keyhole_Dbroot_EndSnippetProto.RockTreeDataProto: @unchecked Sendable {}
extension Keyhole_Dbroot_EndSnippetProto.FilmstripConfigProto: @unchecked Sendable {}
extension Keyhole_Dbroot_EndSnippetProto.FilmstripConfigProto.AlleycatImageryTypeProto: @unchecked Sendable {}
extension Keyhole_Dbroot_EndSnippetProto.StarDataProto: @unchecked Sendable {}
extension Keyhole_Dbroot_DbRootRefProto: @unchecked Sendable {}
extension Keyhole_Dbroot_DatabaseVersionProto: @unchecked Sendable {}
extension Keyhole_Dbroot_DbRootProto: @unchecked Sendable {}
extension Keyhole_Dbroot_EncryptedDbRootProto: @unchecked Sendable {}
extension Keyhole_Dbroot_EncryptedDbRootProto.EncryptionType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "keyhole.dbroot"

extension Keyhole_Dbroot_StringEntryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringEntryProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "string_id"),
    2: .standard(proto: "string_value"),
  ]

  public var isInitialized: Bool {
    if self._stringID == nil {return false}
    if self._stringValue == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._stringID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._stringValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stringID {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stringValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_StringEntryProto, rhs: Keyhole_Dbroot_StringEntryProto) -> Bool {
    if lhs._stringID != rhs._stringID {return false}
    if lhs._stringValue != rhs._stringValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_StringIdOrValueProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringIdOrValueProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "string_id"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._stringID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stringID {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_StringIdOrValueProto, rhs: Keyhole_Dbroot_StringIdOrValueProto) -> Bool {
    if lhs._stringID != rhs._stringID {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_PlanetModelProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlanetModelProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "radius"),
    2: .same(proto: "flattening"),
    4: .standard(proto: "elevation_bias"),
    5: .standard(proto: "negative_altitude_exponent_bias"),
    6: .standard(proto: "compressed_negative_altitude_threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._radius) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._flattening) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._elevationBias) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._negativeAltitudeExponentBias) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self._compressedNegativeAltitudeThreshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._radius {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._flattening {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._elevationBias {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._negativeAltitudeExponentBias {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._compressedNegativeAltitudeThreshold {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_PlanetModelProto, rhs: Keyhole_Dbroot_PlanetModelProto) -> Bool {
    if lhs._radius != rhs._radius {return false}
    if lhs._flattening != rhs._flattening {return false}
    if lhs._elevationBias != rhs._elevationBias {return false}
    if lhs._negativeAltitudeExponentBias != rhs._negativeAltitudeExponentBias {return false}
    if lhs._compressedNegativeAltitudeThreshold != rhs._compressedNegativeAltitudeThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_ProviderInfoProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProviderInfoProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "provider_id"),
    2: .standard(proto: "copyright_string"),
    3: .standard(proto: "vertical_pixel_offset"),
  ]

  public var isInitialized: Bool {
    if self._providerID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._providerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._copyrightString) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._verticalPixelOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._providerID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._copyrightString {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._verticalPixelOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_ProviderInfoProto, rhs: Keyhole_Dbroot_ProviderInfoProto) -> Bool {
    if lhs._providerID != rhs._providerID {return false}
    if lhs._copyrightString != rhs._copyrightString {return false}
    if lhs._verticalPixelOffset != rhs._verticalPixelOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_PopUpProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PopUpProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_balloon_style"),
    2: .same(proto: "text"),
    3: .standard(proto: "background_color_abgr"),
    4: .standard(proto: "text_color_abgr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isBalloonStyle) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._text) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._backgroundColorAbgr) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._textColorAbgr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isBalloonStyle {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._text {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._backgroundColorAbgr {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._textColorAbgr {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_PopUpProto, rhs: Keyhole_Dbroot_PopUpProto) -> Bool {
    if lhs._isBalloonStyle != rhs._isBalloonStyle {return false}
    if lhs._text != rhs._text {return false}
    if lhs._backgroundColorAbgr != rhs._backgroundColorAbgr {return false}
    if lhs._textColorAbgr != rhs._textColorAbgr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_StyleAttributeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleAttributeProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "style_id"),
    3: .standard(proto: "provider_id"),
    4: .standard(proto: "poly_color_abgr"),
    5: .standard(proto: "line_color_abgr"),
    6: .standard(proto: "line_width"),
    7: .standard(proto: "label_color_abgr"),
    8: .standard(proto: "label_scale"),
    9: .standard(proto: "placemark_icon_color_abgr"),
    10: .standard(proto: "placemark_icon_scale"),
    11: .standard(proto: "placemark_icon_path"),
    12: .standard(proto: "placemark_icon_x"),
    13: .standard(proto: "placemark_icon_y"),
    14: .standard(proto: "placemark_icon_width"),
    15: .standard(proto: "placemark_icon_height"),
    16: .standard(proto: "pop_up"),
    17: .standard(proto: "draw_flag"),
  ]

  fileprivate class _StorageClass {
    var _styleID: String? = nil
    var _providerID: Int32? = nil
    var _polyColorAbgr: UInt32? = nil
    var _lineColorAbgr: UInt32? = nil
    var _lineWidth: Float? = nil
    var _labelColorAbgr: UInt32? = nil
    var _labelScale: Float? = nil
    var _placemarkIconColorAbgr: UInt32? = nil
    var _placemarkIconScale: Float? = nil
    var _placemarkIconPath: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _placemarkIconX: Int32? = nil
    var _placemarkIconY: Int32? = nil
    var _placemarkIconWidth: Int32? = nil
    var _placemarkIconHeight: Int32? = nil
    var _popUp: Keyhole_Dbroot_PopUpProto? = nil
    var _drawFlag: [Keyhole_Dbroot_DrawFlagProto] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _styleID = source._styleID
      _providerID = source._providerID
      _polyColorAbgr = source._polyColorAbgr
      _lineColorAbgr = source._lineColorAbgr
      _lineWidth = source._lineWidth
      _labelColorAbgr = source._labelColorAbgr
      _labelScale = source._labelScale
      _placemarkIconColorAbgr = source._placemarkIconColorAbgr
      _placemarkIconScale = source._placemarkIconScale
      _placemarkIconPath = source._placemarkIconPath
      _placemarkIconX = source._placemarkIconX
      _placemarkIconY = source._placemarkIconY
      _placemarkIconWidth = source._placemarkIconWidth
      _placemarkIconHeight = source._placemarkIconHeight
      _popUp = source._popUp
      _drawFlag = source._drawFlag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._styleID == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._drawFlag) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._styleID) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._providerID) }()
        case 4: try { try decoder.decodeSingularFixed32Field(value: &_storage._polyColorAbgr) }()
        case 5: try { try decoder.decodeSingularFixed32Field(value: &_storage._lineColorAbgr) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._lineWidth) }()
        case 7: try { try decoder.decodeSingularFixed32Field(value: &_storage._labelColorAbgr) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._labelScale) }()
        case 9: try { try decoder.decodeSingularFixed32Field(value: &_storage._placemarkIconColorAbgr) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._placemarkIconScale) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._placemarkIconPath) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._placemarkIconX) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._placemarkIconY) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._placemarkIconWidth) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._placemarkIconHeight) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._popUp) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._drawFlag) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._styleID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._providerID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._polyColorAbgr {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._lineColorAbgr {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._lineWidth {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._labelColorAbgr {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._labelScale {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._placemarkIconColorAbgr {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._placemarkIconScale {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._placemarkIconPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._placemarkIconX {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._placemarkIconY {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._placemarkIconWidth {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._placemarkIconHeight {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._popUp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._drawFlag.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._drawFlag, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_StyleAttributeProto, rhs: Keyhole_Dbroot_StyleAttributeProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._styleID != rhs_storage._styleID {return false}
        if _storage._providerID != rhs_storage._providerID {return false}
        if _storage._polyColorAbgr != rhs_storage._polyColorAbgr {return false}
        if _storage._lineColorAbgr != rhs_storage._lineColorAbgr {return false}
        if _storage._lineWidth != rhs_storage._lineWidth {return false}
        if _storage._labelColorAbgr != rhs_storage._labelColorAbgr {return false}
        if _storage._labelScale != rhs_storage._labelScale {return false}
        if _storage._placemarkIconColorAbgr != rhs_storage._placemarkIconColorAbgr {return false}
        if _storage._placemarkIconScale != rhs_storage._placemarkIconScale {return false}
        if _storage._placemarkIconPath != rhs_storage._placemarkIconPath {return false}
        if _storage._placemarkIconX != rhs_storage._placemarkIconX {return false}
        if _storage._placemarkIconY != rhs_storage._placemarkIconY {return false}
        if _storage._placemarkIconWidth != rhs_storage._placemarkIconWidth {return false}
        if _storage._placemarkIconHeight != rhs_storage._placemarkIconHeight {return false}
        if _storage._popUp != rhs_storage._popUp {return false}
        if _storage._drawFlag != rhs_storage._drawFlag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_StyleMapProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleMapProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "style_map_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "normal_style_attribute"),
    4: .standard(proto: "highlight_style_attribute"),
  ]

  public var isInitialized: Bool {
    if self._styleMapID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._styleMapID) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._normalStyleAttribute) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._highlightStyleAttribute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._styleMapID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.channelID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.channelID, fieldNumber: 2)
    }
    try { if let v = self._normalStyleAttribute {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._highlightStyleAttribute {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_StyleMapProto, rhs: Keyhole_Dbroot_StyleMapProto) -> Bool {
    if lhs._styleMapID != rhs._styleMapID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs._normalStyleAttribute != rhs._normalStyleAttribute {return false}
    if lhs._highlightStyleAttribute != rhs._highlightStyleAttribute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_ZoomRangeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZoomRangeProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_zoom"),
    2: .standard(proto: "max_zoom"),
  ]

  public var isInitialized: Bool {
    if self._minZoom == nil {return false}
    if self._maxZoom == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._minZoom) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._maxZoom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._minZoom {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maxZoom {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_ZoomRangeProto, rhs: Keyhole_Dbroot_ZoomRangeProto) -> Bool {
    if lhs._minZoom != rhs._minZoom {return false}
    if lhs._maxZoom != rhs._maxZoom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_DrawFlagProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawFlagProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "draw_flag_type"),
  ]

  public var isInitialized: Bool {
    if self._drawFlagType == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._drawFlagType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._drawFlagType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_DrawFlagProto, rhs: Keyhole_Dbroot_DrawFlagProto) -> Bool {
    if lhs._drawFlagType != rhs._drawFlagType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_DrawFlagProto.DrawFlagType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TYPE_FILL_ONLY"),
    2: .same(proto: "TYPE_OUTLINE_ONLY"),
    3: .same(proto: "TYPE_FILL_AND_OUTLINE"),
    4: .same(proto: "TYPE_ANTIALIASING"),
    5: .same(proto: "TYPE_CENTER_LABEL"),
  ]
}

extension Keyhole_Dbroot_LayerProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LayerProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "zoom_range"),
    2: .standard(proto: "preserve_text_level"),
    4: .standard(proto: "lod_begin_transition"),
    5: .standard(proto: "lod_end_transition"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.zoomRange) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.zoomRange) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._preserveTextLevel) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._lodBeginTransition) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._lodEndTransition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.zoomRange.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.zoomRange, fieldNumber: 1)
    }
    try { if let v = self._preserveTextLevel {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lodBeginTransition {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._lodEndTransition {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_LayerProto, rhs: Keyhole_Dbroot_LayerProto) -> Bool {
    if lhs.zoomRange != rhs.zoomRange {return false}
    if lhs._preserveTextLevel != rhs._preserveTextLevel {return false}
    if lhs._lodBeginTransition != rhs._lodBeginTransition {return false}
    if lhs._lodEndTransition != rhs._lodEndTransition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_FolderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FolderProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_expandable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isExpandable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isExpandable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_FolderProto, rhs: Keyhole_Dbroot_FolderProto) -> Bool {
    if lhs._isExpandable != rhs._isExpandable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_RequirementProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequirementProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "required_vram"),
    4: .standard(proto: "required_client_ver"),
    5: .same(proto: "probability"),
    6: .standard(proto: "required_user_agent"),
    7: .standard(proto: "required_client_capabilities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularStringField(value: &self._requiredVram) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._requiredClientVer) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._probability) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._requiredUserAgent) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._requiredClientCapabilities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requiredVram {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._requiredClientVer {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._probability {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._requiredUserAgent {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._requiredClientCapabilities {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_RequirementProto, rhs: Keyhole_Dbroot_RequirementProto) -> Bool {
    if lhs._requiredVram != rhs._requiredVram {return false}
    if lhs._requiredClientVer != rhs._requiredClientVer {return false}
    if lhs._probability != rhs._probability {return false}
    if lhs._requiredUserAgent != rhs._requiredUserAgent {return false}
    if lhs._requiredClientCapabilities != rhs._requiredClientCapabilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_LookAtProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LookAtProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
    3: .same(proto: "range"),
    4: .same(proto: "tilt"),
    5: .same(proto: "heading"),
  ]

  public var isInitialized: Bool {
    if self._longitude == nil {return false}
    if self._latitude == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._longitude) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._latitude) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._range) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._tilt) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._heading) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._longitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._latitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._range {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._tilt {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._heading {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_LookAtProto, rhs: Keyhole_Dbroot_LookAtProto) -> Bool {
    if lhs._longitude != rhs._longitude {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._range != rhs._range {return false}
    if lhs._tilt != rhs._tilt {return false}
    if lhs._heading != rhs._heading {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_NestedFeatureProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NestedFeatureProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "feature_type"),
    2: .standard(proto: "kml_url"),
    21: .standard(proto: "database_url"),
    3: .same(proto: "layer"),
    4: .same(proto: "folder"),
    5: .same(proto: "requirement"),
    6: .standard(proto: "channel_id"),
    7: .standard(proto: "display_name"),
    8: .standard(proto: "is_visible"),
    9: .standard(proto: "is_enabled"),
    10: .standard(proto: "is_checked"),
    11: .standard(proto: "layer_menu_icon_path"),
    12: .same(proto: "description"),
    13: .standard(proto: "look_at"),
    15: .standard(proto: "asset_uuid"),
    16: .standard(proto: "is_save_locked"),
    17: .same(proto: "children"),
    18: .standard(proto: "client_config_script_name"),
    19: .standard(proto: "diorama_data_channel_base"),
    20: .standard(proto: "replica_data_channel_base"),
  ]

  fileprivate class _StorageClass {
    var _featureType: Keyhole_Dbroot_NestedFeatureProto.FeatureType? = nil
    var _kmlURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _databaseURL: String? = nil
    var _layer: Keyhole_Dbroot_LayerProto? = nil
    var _folder: Keyhole_Dbroot_FolderProto? = nil
    var _requirement: Keyhole_Dbroot_RequirementProto? = nil
    var _channelID: Int32? = nil
    var _displayName: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _isVisible: Bool? = nil
    var _isEnabled: Bool? = nil
    var _isChecked: Bool? = nil
    var _layerMenuIconPath: String? = nil
    var _description_p: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _lookAt: Keyhole_Dbroot_LookAtProto? = nil
    var _assetUuid: String? = nil
    var _isSaveLocked: Bool? = nil
    var _children: [Keyhole_Dbroot_NestedFeatureProto] = []
    var _clientConfigScriptName: String? = nil
    var _dioramaDataChannelBase: Int32? = nil
    var _replicaDataChannelBase: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _featureType = source._featureType
      _kmlURL = source._kmlURL
      _databaseURL = source._databaseURL
      _layer = source._layer
      _folder = source._folder
      _requirement = source._requirement
      _channelID = source._channelID
      _displayName = source._displayName
      _isVisible = source._isVisible
      _isEnabled = source._isEnabled
      _isChecked = source._isChecked
      _layerMenuIconPath = source._layerMenuIconPath
      _description_p = source._description_p
      _lookAt = source._lookAt
      _assetUuid = source._assetUuid
      _isSaveLocked = source._isSaveLocked
      _children = source._children
      _clientConfigScriptName = source._clientConfigScriptName
      _dioramaDataChannelBase = source._dioramaDataChannelBase
      _replicaDataChannelBase = source._replicaDataChannelBase
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._channelID == nil {return false}
      if let v = _storage._layer, !v.isInitialized {return false}
      if let v = _storage._lookAt, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._children) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._featureType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._kmlURL) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._layer) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._folder) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._requirement) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._channelID) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._displayName) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._isVisible) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isEnabled) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isChecked) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._layerMenuIconPath) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._description_p) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._lookAt) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._assetUuid) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._isSaveLocked) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._children) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._clientConfigScriptName) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._dioramaDataChannelBase) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._replicaDataChannelBase) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._databaseURL) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._featureType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._kmlURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._layer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._folder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._requirement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._channelID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._displayName {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._isVisible {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._isEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._isChecked {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._layerMenuIconPath {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._description_p {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._lookAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._assetUuid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._isSaveLocked {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      } }()
      if !_storage._children.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._children, fieldNumber: 17)
      }
      try { if let v = _storage._clientConfigScriptName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._dioramaDataChannelBase {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._replicaDataChannelBase {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._databaseURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_NestedFeatureProto, rhs: Keyhole_Dbroot_NestedFeatureProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._featureType != rhs_storage._featureType {return false}
        if _storage._kmlURL != rhs_storage._kmlURL {return false}
        if _storage._databaseURL != rhs_storage._databaseURL {return false}
        if _storage._layer != rhs_storage._layer {return false}
        if _storage._folder != rhs_storage._folder {return false}
        if _storage._requirement != rhs_storage._requirement {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._isVisible != rhs_storage._isVisible {return false}
        if _storage._isEnabled != rhs_storage._isEnabled {return false}
        if _storage._isChecked != rhs_storage._isChecked {return false}
        if _storage._layerMenuIconPath != rhs_storage._layerMenuIconPath {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._lookAt != rhs_storage._lookAt {return false}
        if _storage._assetUuid != rhs_storage._assetUuid {return false}
        if _storage._isSaveLocked != rhs_storage._isSaveLocked {return false}
        if _storage._children != rhs_storage._children {return false}
        if _storage._clientConfigScriptName != rhs_storage._clientConfigScriptName {return false}
        if _storage._dioramaDataChannelBase != rhs_storage._dioramaDataChannelBase {return false}
        if _storage._replicaDataChannelBase != rhs_storage._replicaDataChannelBase {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_NestedFeatureProto.FeatureType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TYPE_POINT_Z"),
    2: .same(proto: "TYPE_POLYGON_Z"),
    3: .same(proto: "TYPE_LINE_Z"),
    4: .same(proto: "TYPE_TERRAIN"),
  ]
}

extension Keyhole_Dbroot_MfeDomainFeaturesProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MfeDomainFeaturesProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "country_code"),
    2: .standard(proto: "domain_name"),
    3: .standard(proto: "supported_features"),
  ]

  public var isInitialized: Bool {
    if self._countryCode == nil {return false}
    if self._domainName == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._countryCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._domainName) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.supportedFeatures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._countryCode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._domainName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.supportedFeatures.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.supportedFeatures, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_MfeDomainFeaturesProto, rhs: Keyhole_Dbroot_MfeDomainFeaturesProto) -> Bool {
    if lhs._countryCode != rhs._countryCode {return false}
    if lhs._domainName != rhs._domainName {return false}
    if lhs.supportedFeatures != rhs.supportedFeatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_MfeDomainFeaturesProto.SupportedFeature: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GEOCODING"),
    1: .same(proto: "LOCAL_SEARCH"),
    2: .same(proto: "DRIVING_DIRECTIONS"),
  ]
}

extension Keyhole_Dbroot_ClientOptionsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientOptionsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "disable_disk_cache"),
    2: .standard(proto: "disable_embedded_browser_vista"),
    3: .standard(proto: "draw_atmosphere"),
    4: .standard(proto: "draw_stars"),
    5: .standard(proto: "shader_file_prefix"),
    6: .standard(proto: "use_protobuf_quadtree_packets"),
    7: .standard(proto: "use_extended_copyright_ids"),
    8: .standard(proto: "precipitations_options"),
    9: .standard(proto: "capture_options"),
    10: .standard(proto: "show_2d_maps_icon"),
    11: .standard(proto: "disable_internal_browser"),
    12: .standard(proto: "internal_browser_blacklist"),
    13: .standard(proto: "internal_browser_origin_whitelist"),
    14: .standard(proto: "polar_tile_merging_level"),
    15: .standard(proto: "js_bridge_request_whitelist"),
    16: .standard(proto: "maps_options"),
  ]

  fileprivate class _StorageClass {
    var _disableDiskCache: Bool? = nil
    var _disableEmbeddedBrowserVista: Bool? = nil
    var _drawAtmosphere: Bool? = nil
    var _drawStars: Bool? = nil
    var _shaderFilePrefix: String? = nil
    var _useProtobufQuadtreePackets: Bool? = nil
    var _useExtendedCopyrightIds: Bool? = nil
    var _precipitationsOptions: Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions? = nil
    var _captureOptions: Keyhole_Dbroot_ClientOptionsProto.CaptureOptions? = nil
    var _show2DMapsIcon: Bool? = nil
    var _disableInternalBrowser: Bool? = nil
    var _internalBrowserBlacklist: String? = nil
    var _internalBrowserOriginWhitelist: String? = nil
    var _polarTileMergingLevel: Int32? = nil
    var _jsBridgeRequestWhitelist: String? = nil
    var _mapsOptions: Keyhole_Dbroot_ClientOptionsProto.MapsOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _disableDiskCache = source._disableDiskCache
      _disableEmbeddedBrowserVista = source._disableEmbeddedBrowserVista
      _drawAtmosphere = source._drawAtmosphere
      _drawStars = source._drawStars
      _shaderFilePrefix = source._shaderFilePrefix
      _useProtobufQuadtreePackets = source._useProtobufQuadtreePackets
      _useExtendedCopyrightIds = source._useExtendedCopyrightIds
      _precipitationsOptions = source._precipitationsOptions
      _captureOptions = source._captureOptions
      _show2DMapsIcon = source._show2DMapsIcon
      _disableInternalBrowser = source._disableInternalBrowser
      _internalBrowserBlacklist = source._internalBrowserBlacklist
      _internalBrowserOriginWhitelist = source._internalBrowserOriginWhitelist
      _polarTileMergingLevel = source._polarTileMergingLevel
      _jsBridgeRequestWhitelist = source._jsBridgeRequestWhitelist
      _mapsOptions = source._mapsOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._precipitationsOptions, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._disableDiskCache) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._disableEmbeddedBrowserVista) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._drawAtmosphere) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._drawStars) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._shaderFilePrefix) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._useProtobufQuadtreePackets) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._useExtendedCopyrightIds) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._precipitationsOptions) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._captureOptions) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._show2DMapsIcon) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._disableInternalBrowser) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._internalBrowserBlacklist) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._internalBrowserOriginWhitelist) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._polarTileMergingLevel) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._jsBridgeRequestWhitelist) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._mapsOptions) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._disableDiskCache {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._disableEmbeddedBrowserVista {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._drawAtmosphere {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._drawStars {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._shaderFilePrefix {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._useProtobufQuadtreePackets {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._useExtendedCopyrightIds {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._precipitationsOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._captureOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._show2DMapsIcon {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._disableInternalBrowser {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._internalBrowserBlacklist {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._internalBrowserOriginWhitelist {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._polarTileMergingLevel {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._jsBridgeRequestWhitelist {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._mapsOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_ClientOptionsProto, rhs: Keyhole_Dbroot_ClientOptionsProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._disableDiskCache != rhs_storage._disableDiskCache {return false}
        if _storage._disableEmbeddedBrowserVista != rhs_storage._disableEmbeddedBrowserVista {return false}
        if _storage._drawAtmosphere != rhs_storage._drawAtmosphere {return false}
        if _storage._drawStars != rhs_storage._drawStars {return false}
        if _storage._shaderFilePrefix != rhs_storage._shaderFilePrefix {return false}
        if _storage._useProtobufQuadtreePackets != rhs_storage._useProtobufQuadtreePackets {return false}
        if _storage._useExtendedCopyrightIds != rhs_storage._useExtendedCopyrightIds {return false}
        if _storage._precipitationsOptions != rhs_storage._precipitationsOptions {return false}
        if _storage._captureOptions != rhs_storage._captureOptions {return false}
        if _storage._show2DMapsIcon != rhs_storage._show2DMapsIcon {return false}
        if _storage._disableInternalBrowser != rhs_storage._disableInternalBrowser {return false}
        if _storage._internalBrowserBlacklist != rhs_storage._internalBrowserBlacklist {return false}
        if _storage._internalBrowserOriginWhitelist != rhs_storage._internalBrowserOriginWhitelist {return false}
        if _storage._polarTileMergingLevel != rhs_storage._polarTileMergingLevel {return false}
        if _storage._jsBridgeRequestWhitelist != rhs_storage._jsBridgeRequestWhitelist {return false}
        if _storage._mapsOptions != rhs_storage._mapsOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_ClientOptionsProto.protoMessageName + ".PrecipitationsOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_url"),
    2: .standard(proto: "image_expire_time"),
    3: .standard(proto: "max_color_distance"),
    4: .standard(proto: "image_level"),
    5: .standard(proto: "weather_mapping"),
    6: .standard(proto: "clouds_layer_url"),
    7: .standard(proto: "animation_deceleration_delay"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.weatherMapping) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._imageURL) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._imageExpireTime) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._maxColorDistance) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._imageLevel) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.weatherMapping) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._cloudsLayerURL) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self._animationDecelerationDelay) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._imageURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._imageExpireTime {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._maxColorDistance {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._imageLevel {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    if !self.weatherMapping.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weatherMapping, fieldNumber: 5)
    }
    try { if let v = self._cloudsLayerURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._animationDecelerationDelay {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions, rhs: Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions) -> Bool {
    if lhs._imageURL != rhs._imageURL {return false}
    if lhs._imageExpireTime != rhs._imageExpireTime {return false}
    if lhs._maxColorDistance != rhs._maxColorDistance {return false}
    if lhs._imageLevel != rhs._imageLevel {return false}
    if lhs.weatherMapping != rhs.weatherMapping {return false}
    if lhs._cloudsLayerURL != rhs._cloudsLayerURL {return false}
    if lhs._animationDecelerationDelay != rhs._animationDecelerationDelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions.WeatherMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions.protoMessageName + ".WeatherMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "color_abgr"),
    2: .standard(proto: "weather_type"),
    3: .same(proto: "elongation"),
    4: .same(proto: "opacity"),
    5: .standard(proto: "fog_density"),
    6: .same(proto: "speed0"),
    7: .same(proto: "speed1"),
    8: .same(proto: "speed2"),
    9: .same(proto: "speed3"),
  ]

  public var isInitialized: Bool {
    if self._colorAbgr == nil {return false}
    if self._weatherType == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._colorAbgr) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._weatherType) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._elongation) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._opacity) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._fogDensity) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self._speed0) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self._speed1) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self._speed2) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self._speed3) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._colorAbgr {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._weatherType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._elongation {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._opacity {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._fogDensity {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._speed0 {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._speed1 {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._speed2 {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._speed3 {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions.WeatherMapping, rhs: Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions.WeatherMapping) -> Bool {
    if lhs._colorAbgr != rhs._colorAbgr {return false}
    if lhs._weatherType != rhs._weatherType {return false}
    if lhs._elongation != rhs._elongation {return false}
    if lhs._opacity != rhs._opacity {return false}
    if lhs._fogDensity != rhs._fogDensity {return false}
    if lhs._speed0 != rhs._speed0 {return false}
    if lhs._speed1 != rhs._speed1 {return false}
    if lhs._speed2 != rhs._speed2 {return false}
    if lhs._speed3 != rhs._speed3 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_ClientOptionsProto.PrecipitationsOptions.WeatherMapping.WeatherType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_PRECIPITATION"),
    1: .same(proto: "RAIN"),
    2: .same(proto: "SNOW"),
  ]
}

extension Keyhole_Dbroot_ClientOptionsProto.CaptureOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_ClientOptionsProto.protoMessageName + ".CaptureOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allow_save_as_image"),
    2: .standard(proto: "max_free_capture_res"),
    3: .standard(proto: "max_premium_capture_res"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._allowSaveAsImage) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._maxFreeCaptureRes) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._maxPremiumCaptureRes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._allowSaveAsImage {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maxFreeCaptureRes {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._maxPremiumCaptureRes {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_ClientOptionsProto.CaptureOptions, rhs: Keyhole_Dbroot_ClientOptionsProto.CaptureOptions) -> Bool {
    if lhs._allowSaveAsImage != rhs._allowSaveAsImage {return false}
    if lhs._maxFreeCaptureRes != rhs._maxFreeCaptureRes {return false}
    if lhs._maxPremiumCaptureRes != rhs._maxPremiumCaptureRes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_ClientOptionsProto.MapsOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_ClientOptionsProto.protoMessageName + ".MapsOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enable_maps"),
    2: .standard(proto: "docs_auto_download_enabled"),
    3: .standard(proto: "docs_auto_download_interval"),
    4: .standard(proto: "docs_auto_upload_enabled"),
    5: .standard(proto: "docs_auto_upload_delay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._enableMaps) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._docsAutoDownloadEnabled) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._docsAutoDownloadInterval) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._docsAutoUploadEnabled) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._docsAutoUploadDelay) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._enableMaps {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._docsAutoDownloadEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._docsAutoDownloadInterval {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._docsAutoUploadEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._docsAutoUploadDelay {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_ClientOptionsProto.MapsOptions, rhs: Keyhole_Dbroot_ClientOptionsProto.MapsOptions) -> Bool {
    if lhs._enableMaps != rhs._enableMaps {return false}
    if lhs._docsAutoDownloadEnabled != rhs._docsAutoDownloadEnabled {return false}
    if lhs._docsAutoDownloadInterval != rhs._docsAutoDownloadInterval {return false}
    if lhs._docsAutoUploadEnabled != rhs._docsAutoUploadEnabled {return false}
    if lhs._docsAutoUploadDelay != rhs._docsAutoUploadDelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_FetchingOptionsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FetchingOptionsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_requests_per_query"),
    12: .standard(proto: "force_max_requests_per_query"),
    13: .standard(proto: "sort_batches"),
    2: .standard(proto: "max_drawable"),
    3: .standard(proto: "max_imagery"),
    4: .standard(proto: "max_terrain"),
    5: .standard(proto: "max_quadtree"),
    6: .standard(proto: "max_diorama_metadata"),
    7: .standard(proto: "max_diorama_data"),
    8: .standard(proto: "max_consumer_fetch_ratio"),
    9: .standard(proto: "max_pro_ec_fetch_ratio"),
    10: .standard(proto: "safe_overall_qps"),
    11: .standard(proto: "safe_imagery_qps"),
    14: .standard(proto: "domains_for_https"),
    15: .standard(proto: "hosts_for_http"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._maxRequestsPerQuery) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._maxDrawable) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._maxImagery) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._maxTerrain) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._maxQuadtree) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._maxDioramaMetadata) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._maxDioramaData) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self._maxConsumerFetchRatio) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self._maxProEcFetchRatio) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self._safeOverallQps) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self._safeImageryQps) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self._forceMaxRequestsPerQuery) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self._sortBatches) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self._domainsForHTTPS) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self._hostsForHTTP) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._maxRequestsPerQuery {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maxDrawable {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._maxImagery {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maxTerrain {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._maxQuadtree {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._maxDioramaMetadata {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._maxDioramaData {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._maxConsumerFetchRatio {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._maxProEcFetchRatio {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._safeOverallQps {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._safeImageryQps {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._forceMaxRequestsPerQuery {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._sortBatches {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._domainsForHTTPS {
      try visitor.visitSingularStringField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._hostsForHTTP {
      try visitor.visitSingularStringField(value: v, fieldNumber: 15)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_FetchingOptionsProto, rhs: Keyhole_Dbroot_FetchingOptionsProto) -> Bool {
    if lhs._maxRequestsPerQuery != rhs._maxRequestsPerQuery {return false}
    if lhs._forceMaxRequestsPerQuery != rhs._forceMaxRequestsPerQuery {return false}
    if lhs._sortBatches != rhs._sortBatches {return false}
    if lhs._maxDrawable != rhs._maxDrawable {return false}
    if lhs._maxImagery != rhs._maxImagery {return false}
    if lhs._maxTerrain != rhs._maxTerrain {return false}
    if lhs._maxQuadtree != rhs._maxQuadtree {return false}
    if lhs._maxDioramaMetadata != rhs._maxDioramaMetadata {return false}
    if lhs._maxDioramaData != rhs._maxDioramaData {return false}
    if lhs._maxConsumerFetchRatio != rhs._maxConsumerFetchRatio {return false}
    if lhs._maxProEcFetchRatio != rhs._maxProEcFetchRatio {return false}
    if lhs._safeOverallQps != rhs._safeOverallQps {return false}
    if lhs._safeImageryQps != rhs._safeImageryQps {return false}
    if lhs._domainsForHTTPS != rhs._domainsForHTTPS {return false}
    if lhs._hostsForHTTP != rhs._hostsForHTTP {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_TimeMachineOptionsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeMachineOptionsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_url"),
    2: .standard(proto: "is_timemachine"),
    3: .standard(proto: "dwell_time_ms"),
    4: .standard(proto: "discoverability_altitude_meters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._serverURL) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isTimemachine) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._dwellTimeMs) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._discoverabilityAltitudeMeters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serverURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isTimemachine {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dwellTimeMs {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._discoverabilityAltitudeMeters {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_TimeMachineOptionsProto, rhs: Keyhole_Dbroot_TimeMachineOptionsProto) -> Bool {
    if lhs._serverURL != rhs._serverURL {return false}
    if lhs._isTimemachine != rhs._isTimemachine {return false}
    if lhs._dwellTimeMs != rhs._dwellTimeMs {return false}
    if lhs._discoverabilityAltitudeMeters != rhs._discoverabilityAltitudeMeters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_AutopiaOptionsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutopiaOptionsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metadata_server_url"),
    2: .standard(proto: "depthmap_server_url"),
    3: .standard(proto: "coverage_overlay_url"),
    4: .standard(proto: "max_imagery_qps"),
    5: .standard(proto: "max_metadata_depthmap_qps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._metadataServerURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._depthmapServerURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._coverageOverlayURL) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._maxImageryQps) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._maxMetadataDepthmapQps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadataServerURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._depthmapServerURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._coverageOverlayURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maxImageryQps {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._maxMetadataDepthmapQps {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_AutopiaOptionsProto, rhs: Keyhole_Dbroot_AutopiaOptionsProto) -> Bool {
    if lhs._metadataServerURL != rhs._metadataServerURL {return false}
    if lhs._depthmapServerURL != rhs._depthmapServerURL {return false}
    if lhs._coverageOverlayURL != rhs._coverageOverlayURL {return false}
    if lhs._maxImageryQps != rhs._maxImageryQps {return false}
    if lhs._maxMetadataDepthmapQps != rhs._maxMetadataDepthmapQps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_CSIOptionsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CSIOptionsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sampling_percentage"),
    2: .standard(proto: "experiment_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._samplingPercentage) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._experimentID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._samplingPercentage {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._experimentID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_CSIOptionsProto, rhs: Keyhole_Dbroot_CSIOptionsProto) -> Bool {
    if lhs._samplingPercentage != rhs._samplingPercentage {return false}
    if lhs._experimentID != rhs._experimentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_SearchTabProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SearchTabProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_visible"),
    2: .standard(proto: "tab_label"),
    3: .standard(proto: "base_url"),
    4: .standard(proto: "viewport_prefix"),
    5: .standard(proto: "input_box"),
    6: .same(proto: "requirement"),
  ]

  public var isInitialized: Bool {
    if self._isVisible == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.inputBox) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isVisible) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tabLabel) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._baseURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._viewportPrefix) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.inputBox) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._requirement) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isVisible {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tabLabel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._baseURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._viewportPrefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.inputBox.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputBox, fieldNumber: 5)
    }
    try { if let v = self._requirement {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_SearchTabProto, rhs: Keyhole_Dbroot_SearchTabProto) -> Bool {
    if lhs._isVisible != rhs._isVisible {return false}
    if lhs._tabLabel != rhs._tabLabel {return false}
    if lhs._baseURL != rhs._baseURL {return false}
    if lhs._viewportPrefix != rhs._viewportPrefix {return false}
    if lhs.inputBox != rhs.inputBox {return false}
    if lhs._requirement != rhs._requirement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_SearchTabProto.InputBoxInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_SearchTabProto.protoMessageName + ".InputBoxInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .standard(proto: "query_verb"),
    3: .standard(proto: "query_prepend"),
  ]

  public var isInitialized: Bool {
    if self._label == nil {return false}
    if self._queryVerb == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._queryVerb) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._queryPrepend) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._label {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._queryVerb {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._queryPrepend {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_SearchTabProto.InputBoxInfo, rhs: Keyhole_Dbroot_SearchTabProto.InputBoxInfo) -> Bool {
    if lhs._label != rhs._label {return false}
    if lhs._queryVerb != rhs._queryVerb {return false}
    if lhs._queryPrepend != rhs._queryPrepend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_CobrandProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CobrandProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "logo_url"),
    2: .standard(proto: "x_coord"),
    3: .standard(proto: "y_coord"),
    4: .standard(proto: "tie_point"),
    5: .standard(proto: "screen_size"),
  ]

  public var isInitialized: Bool {
    if self._logoURL == nil {return false}
    if let v = self._xCoord, !v.isInitialized {return false}
    if let v = self._yCoord, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._logoURL) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._xCoord) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._yCoord) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._tiePoint) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._screenSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._logoURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._xCoord {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._yCoord {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._tiePoint {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._screenSize {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_CobrandProto, rhs: Keyhole_Dbroot_CobrandProto) -> Bool {
    if lhs._logoURL != rhs._logoURL {return false}
    if lhs._xCoord != rhs._xCoord {return false}
    if lhs._yCoord != rhs._yCoord {return false}
    if lhs._tiePoint != rhs._tiePoint {return false}
    if lhs._screenSize != rhs._screenSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_CobrandProto.TiePoint: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TOP_LEFT"),
    1: .same(proto: "TOP_CENTER"),
    2: .same(proto: "TOP_RIGHT"),
    3: .same(proto: "MID_LEFT"),
    4: .same(proto: "MID_CENTER"),
    5: .same(proto: "MID_RIGHT"),
    6: .same(proto: "BOTTOM_LEFT"),
    7: .same(proto: "BOTTOM_CENTER"),
    8: .same(proto: "BOTTOM_RIGHT"),
  ]
}

extension Keyhole_Dbroot_CobrandProto.Coord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_CobrandProto.protoMessageName + ".Coord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "is_relative"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isRelative) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isRelative {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_CobrandProto.Coord, rhs: Keyhole_Dbroot_CobrandProto.Coord) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._isRelative != rhs._isRelative {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_DatabaseDescriptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseDescriptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "database_name"),
    2: .standard(proto: "database_url"),
  ]

  public var isInitialized: Bool {
    if self._databaseURL == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._databaseName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._databaseURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._databaseName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._databaseURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_DatabaseDescriptionProto, rhs: Keyhole_Dbroot_DatabaseDescriptionProto) -> Bool {
    if lhs._databaseName != rhs._databaseName {return false}
    if lhs._databaseURL != rhs._databaseURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_ConfigScriptProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigScriptProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "script_name"),
    2: .standard(proto: "script_data"),
  ]

  public var isInitialized: Bool {
    if self._scriptName == nil {return false}
    if self._scriptData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._scriptName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._scriptData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scriptName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._scriptData {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_ConfigScriptProto, rhs: Keyhole_Dbroot_ConfigScriptProto) -> Bool {
    if lhs._scriptName != rhs._scriptName {return false}
    if lhs._scriptData != rhs._scriptData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_SwoopParamsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SwoopParamsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_dist_in_meters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._startDistInMeters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startDistInMeters {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_SwoopParamsProto, rhs: Keyhole_Dbroot_SwoopParamsProto) -> Bool {
    if lhs._startDistInMeters != rhs._startDistInMeters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_PostingServerProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PostingServerProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "base_url"),
    3: .standard(proto: "post_wizard_path"),
    4: .standard(proto: "file_submit_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._baseURL) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._postWizardPath) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._fileSubmitPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._baseURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._postWizardPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._fileSubmitPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_PostingServerProto, rhs: Keyhole_Dbroot_PostingServerProto) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._baseURL != rhs._baseURL {return false}
    if lhs._postWizardPath != rhs._postWizardPath {return false}
    if lhs._fileSubmitPath != rhs._fileSubmitPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_PlanetaryDatabaseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlanetaryDatabaseProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "name"),
  ]

  public var isInitialized: Bool {
    if self._url == nil {return false}
    if self._name == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_PlanetaryDatabaseProto, rhs: Keyhole_Dbroot_PlanetaryDatabaseProto) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_LogServerProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogServerProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "enable"),
    3: .standard(proto: "throttling_factor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._enable) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._throttlingFactor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._enable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._throttlingFactor {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_LogServerProto, rhs: Keyhole_Dbroot_LogServerProto) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._enable != rhs._enable {return false}
    if lhs._throttlingFactor != rhs._throttlingFactor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_EndSnippetProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EndSnippetProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
    2: .standard(proto: "auth_server_url"),
    3: .standard(proto: "disable_authentication"),
    4: .standard(proto: "mfe_domains"),
    5: .standard(proto: "mfe_lang_param"),
    6: .standard(proto: "ads_url_patterns"),
    7: .standard(proto: "reverse_geocoder_url"),
    8: .standard(proto: "reverse_geocoder_protocol_version"),
    9: .standard(proto: "sky_database_is_available"),
    10: .standard(proto: "sky_database_url"),
    11: .standard(proto: "default_web_page_intl_url"),
    12: .standard(proto: "num_start_up_tips"),
    13: .standard(proto: "start_up_tips_url"),
    51: .standard(proto: "num_pro_start_up_tips"),
    52: .standard(proto: "pro_start_up_tips_url"),
    64: .standard(proto: "startup_tips_intl_url"),
    14: .standard(proto: "user_guide_intl_url"),
    15: .standard(proto: "support_center_intl_url"),
    16: .standard(proto: "business_listing_intl_url"),
    17: .standard(proto: "support_answer_intl_url"),
    18: .standard(proto: "support_topic_intl_url"),
    19: .standard(proto: "support_request_intl_url"),
    20: .standard(proto: "earth_intl_url"),
    21: .standard(proto: "add_content_url"),
    22: .standard(proto: "sketchup_not_installed_url"),
    23: .standard(proto: "sketchup_error_url"),
    24: .standard(proto: "free_license_url"),
    25: .standard(proto: "pro_license_url"),
    48: .standard(proto: "tutorial_url"),
    49: .standard(proto: "keyboard_shortcuts_url"),
    50: .standard(proto: "release_notes_url"),
    26: .standard(proto: "hide_user_data"),
    27: .standard(proto: "use_ge_logo"),
    28: .standard(proto: "diorama_description_url_base"),
    29: .standard(proto: "diorama_default_color"),
    53: .standard(proto: "diorama_blacklist_url"),
    30: .standard(proto: "client_options"),
    31: .standard(proto: "fetching_options"),
    32: .standard(proto: "time_machine_options"),
    33: .standard(proto: "csi_options"),
    34: .standard(proto: "search_tab"),
    35: .standard(proto: "cobrand_info"),
    36: .standard(proto: "valid_database"),
    37: .standard(proto: "config_script"),
    38: .standard(proto: "deauth_server_url"),
    39: .standard(proto: "swoop_parameters"),
    40: .standard(proto: "bbs_server_info"),
    41: .standard(proto: "data_error_server_info"),
    42: .standard(proto: "planetary_database"),
    43: .standard(proto: "log_server"),
    44: .standard(proto: "autopia_options"),
    54: .standard(proto: "search_config"),
    45: .standard(proto: "search_info"),
    46: .standard(proto: "elevation_service_base_url"),
    47: .standard(proto: "elevation_profile_query_delay"),
    55: .standard(proto: "pro_upgrade_url"),
    56: .standard(proto: "earth_community_url"),
    57: .standard(proto: "google_maps_url"),
    58: .standard(proto: "sharing_url"),
    59: .standard(proto: "privacy_policy_url"),
    60: .standard(proto: "do_gplus_user_check"),
    61: .standard(proto: "rocktree_data_proto"),
    62: .standard(proto: "filmstrip_config"),
    63: .standard(proto: "show_signin_button"),
    65: .standard(proto: "pro_measure_upsell_url"),
    66: .standard(proto: "pro_print_upsell_url"),
    67: .standard(proto: "star_data_proto"),
    68: .standard(proto: "feedback_url"),
    69: .standard(proto: "oauth2_login_url"),
  ]

  fileprivate class _StorageClass {
    var _model: Keyhole_Dbroot_PlanetModelProto? = nil
    var _authServerURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _disableAuthentication: Bool? = nil
    var _mfeDomains: [Keyhole_Dbroot_MfeDomainFeaturesProto] = []
    var _mfeLangParam: String? = nil
    var _adsURLPatterns: String? = nil
    var _reverseGeocoderURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _reverseGeocoderProtocolVersion: Int32? = nil
    var _skyDatabaseIsAvailable: Bool? = nil
    var _skyDatabaseURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _defaultWebPageIntlURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _numStartUpTips: Int32? = nil
    var _startUpTipsURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _numProStartUpTips: Int32? = nil
    var _proStartUpTipsURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _startupTipsIntlURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _userGuideIntlURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _supportCenterIntlURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _businessListingIntlURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _supportAnswerIntlURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _supportTopicIntlURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _supportRequestIntlURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _earthIntlURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _addContentURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _sketchupNotInstalledURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _sketchupErrorURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _freeLicenseURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _proLicenseURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _tutorialURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _keyboardShortcutsURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _releaseNotesURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _hideUserData: Bool? = nil
    var _useGeLogo: Bool? = nil
    var _dioramaDescriptionURLBase: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _dioramaDefaultColor: UInt32? = nil
    var _dioramaBlacklistURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _clientOptions: Keyhole_Dbroot_ClientOptionsProto? = nil
    var _fetchingOptions: Keyhole_Dbroot_FetchingOptionsProto? = nil
    var _timeMachineOptions: Keyhole_Dbroot_TimeMachineOptionsProto? = nil
    var _csiOptions: Keyhole_Dbroot_CSIOptionsProto? = nil
    var _searchTab: [Keyhole_Dbroot_SearchTabProto] = []
    var _cobrandInfo: [Keyhole_Dbroot_CobrandProto] = []
    var _validDatabase: [Keyhole_Dbroot_DatabaseDescriptionProto] = []
    var _configScript: [Keyhole_Dbroot_ConfigScriptProto] = []
    var _deauthServerURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _swoopParameters: Keyhole_Dbroot_SwoopParamsProto? = nil
    var _bbsServerInfo: Keyhole_Dbroot_PostingServerProto? = nil
    var _dataErrorServerInfo: Keyhole_Dbroot_PostingServerProto? = nil
    var _planetaryDatabase: [Keyhole_Dbroot_PlanetaryDatabaseProto] = []
    var _logServer: Keyhole_Dbroot_LogServerProto? = nil
    var _autopiaOptions: Keyhole_Dbroot_AutopiaOptionsProto? = nil
    var _searchConfig: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto? = nil
    var _searchInfo: Keyhole_Dbroot_EndSnippetProto.SearchInfoProto? = nil
    var _elevationServiceBaseURL: String? = nil
    var _elevationProfileQueryDelay: Int32? = nil
    var _proUpgradeURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _earthCommunityURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _googleMapsURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _sharingURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _privacyPolicyURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _doGplusUserCheck: Bool? = nil
    var _rocktreeDataProto: Keyhole_Dbroot_EndSnippetProto.RockTreeDataProto? = nil
    var _filmstripConfig: [Keyhole_Dbroot_EndSnippetProto.FilmstripConfigProto] = []
    var _showSigninButton: Bool? = nil
    var _proMeasureUpsellURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _proPrintUpsellURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _starDataProto: Keyhole_Dbroot_EndSnippetProto.StarDataProto? = nil
    var _feedbackURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _oauth2LoginURL: Keyhole_Dbroot_StringIdOrValueProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _model = source._model
      _authServerURL = source._authServerURL
      _disableAuthentication = source._disableAuthentication
      _mfeDomains = source._mfeDomains
      _mfeLangParam = source._mfeLangParam
      _adsURLPatterns = source._adsURLPatterns
      _reverseGeocoderURL = source._reverseGeocoderURL
      _reverseGeocoderProtocolVersion = source._reverseGeocoderProtocolVersion
      _skyDatabaseIsAvailable = source._skyDatabaseIsAvailable
      _skyDatabaseURL = source._skyDatabaseURL
      _defaultWebPageIntlURL = source._defaultWebPageIntlURL
      _numStartUpTips = source._numStartUpTips
      _startUpTipsURL = source._startUpTipsURL
      _numProStartUpTips = source._numProStartUpTips
      _proStartUpTipsURL = source._proStartUpTipsURL
      _startupTipsIntlURL = source._startupTipsIntlURL
      _userGuideIntlURL = source._userGuideIntlURL
      _supportCenterIntlURL = source._supportCenterIntlURL
      _businessListingIntlURL = source._businessListingIntlURL
      _supportAnswerIntlURL = source._supportAnswerIntlURL
      _supportTopicIntlURL = source._supportTopicIntlURL
      _supportRequestIntlURL = source._supportRequestIntlURL
      _earthIntlURL = source._earthIntlURL
      _addContentURL = source._addContentURL
      _sketchupNotInstalledURL = source._sketchupNotInstalledURL
      _sketchupErrorURL = source._sketchupErrorURL
      _freeLicenseURL = source._freeLicenseURL
      _proLicenseURL = source._proLicenseURL
      _tutorialURL = source._tutorialURL
      _keyboardShortcutsURL = source._keyboardShortcutsURL
      _releaseNotesURL = source._releaseNotesURL
      _hideUserData = source._hideUserData
      _useGeLogo = source._useGeLogo
      _dioramaDescriptionURLBase = source._dioramaDescriptionURLBase
      _dioramaDefaultColor = source._dioramaDefaultColor
      _dioramaBlacklistURL = source._dioramaBlacklistURL
      _clientOptions = source._clientOptions
      _fetchingOptions = source._fetchingOptions
      _timeMachineOptions = source._timeMachineOptions
      _csiOptions = source._csiOptions
      _searchTab = source._searchTab
      _cobrandInfo = source._cobrandInfo
      _validDatabase = source._validDatabase
      _configScript = source._configScript
      _deauthServerURL = source._deauthServerURL
      _swoopParameters = source._swoopParameters
      _bbsServerInfo = source._bbsServerInfo
      _dataErrorServerInfo = source._dataErrorServerInfo
      _planetaryDatabase = source._planetaryDatabase
      _logServer = source._logServer
      _autopiaOptions = source._autopiaOptions
      _searchConfig = source._searchConfig
      _searchInfo = source._searchInfo
      _elevationServiceBaseURL = source._elevationServiceBaseURL
      _elevationProfileQueryDelay = source._elevationProfileQueryDelay
      _proUpgradeURL = source._proUpgradeURL
      _earthCommunityURL = source._earthCommunityURL
      _googleMapsURL = source._googleMapsURL
      _sharingURL = source._sharingURL
      _privacyPolicyURL = source._privacyPolicyURL
      _doGplusUserCheck = source._doGplusUserCheck
      _rocktreeDataProto = source._rocktreeDataProto
      _filmstripConfig = source._filmstripConfig
      _showSigninButton = source._showSigninButton
      _proMeasureUpsellURL = source._proMeasureUpsellURL
      _proPrintUpsellURL = source._proPrintUpsellURL
      _starDataProto = source._starDataProto
      _feedbackURL = source._feedbackURL
      _oauth2LoginURL = source._oauth2LoginURL
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._mfeDomains) {return false}
      if let v = _storage._clientOptions, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._searchTab) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._cobrandInfo) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._validDatabase) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._configScript) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._planetaryDatabase) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._model) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._authServerURL) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._disableAuthentication) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._mfeDomains) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._mfeLangParam) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._adsURLPatterns) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._reverseGeocoderURL) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._reverseGeocoderProtocolVersion) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._skyDatabaseIsAvailable) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._skyDatabaseURL) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._defaultWebPageIntlURL) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._numStartUpTips) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._startUpTipsURL) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._userGuideIntlURL) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._supportCenterIntlURL) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._businessListingIntlURL) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._supportAnswerIntlURL) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._supportTopicIntlURL) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._supportRequestIntlURL) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._earthIntlURL) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._addContentURL) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._sketchupNotInstalledURL) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._sketchupErrorURL) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._freeLicenseURL) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._proLicenseURL) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._hideUserData) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._useGeLogo) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._dioramaDescriptionURLBase) }()
        case 29: try { try decoder.decodeSingularUInt32Field(value: &_storage._dioramaDefaultColor) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._clientOptions) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._fetchingOptions) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._timeMachineOptions) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._csiOptions) }()
        case 34: try { try decoder.decodeRepeatedMessageField(value: &_storage._searchTab) }()
        case 35: try { try decoder.decodeRepeatedMessageField(value: &_storage._cobrandInfo) }()
        case 36: try { try decoder.decodeRepeatedMessageField(value: &_storage._validDatabase) }()
        case 37: try { try decoder.decodeRepeatedMessageField(value: &_storage._configScript) }()
        case 38: try { try decoder.decodeSingularMessageField(value: &_storage._deauthServerURL) }()
        case 39: try { try decoder.decodeSingularMessageField(value: &_storage._swoopParameters) }()
        case 40: try { try decoder.decodeSingularMessageField(value: &_storage._bbsServerInfo) }()
        case 41: try { try decoder.decodeSingularMessageField(value: &_storage._dataErrorServerInfo) }()
        case 42: try { try decoder.decodeRepeatedMessageField(value: &_storage._planetaryDatabase) }()
        case 43: try { try decoder.decodeSingularMessageField(value: &_storage._logServer) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._autopiaOptions) }()
        case 45: try { try decoder.decodeSingularMessageField(value: &_storage._searchInfo) }()
        case 46: try { try decoder.decodeSingularStringField(value: &_storage._elevationServiceBaseURL) }()
        case 47: try { try decoder.decodeSingularInt32Field(value: &_storage._elevationProfileQueryDelay) }()
        case 48: try { try decoder.decodeSingularMessageField(value: &_storage._tutorialURL) }()
        case 49: try { try decoder.decodeSingularMessageField(value: &_storage._keyboardShortcutsURL) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._releaseNotesURL) }()
        case 51: try { try decoder.decodeSingularInt32Field(value: &_storage._numProStartUpTips) }()
        case 52: try { try decoder.decodeSingularMessageField(value: &_storage._proStartUpTipsURL) }()
        case 53: try { try decoder.decodeSingularMessageField(value: &_storage._dioramaBlacklistURL) }()
        case 54: try { try decoder.decodeSingularMessageField(value: &_storage._searchConfig) }()
        case 55: try { try decoder.decodeSingularMessageField(value: &_storage._proUpgradeURL) }()
        case 56: try { try decoder.decodeSingularMessageField(value: &_storage._earthCommunityURL) }()
        case 57: try { try decoder.decodeSingularMessageField(value: &_storage._googleMapsURL) }()
        case 58: try { try decoder.decodeSingularMessageField(value: &_storage._sharingURL) }()
        case 59: try { try decoder.decodeSingularMessageField(value: &_storage._privacyPolicyURL) }()
        case 60: try { try decoder.decodeSingularBoolField(value: &_storage._doGplusUserCheck) }()
        case 61: try { try decoder.decodeSingularMessageField(value: &_storage._rocktreeDataProto) }()
        case 62: try { try decoder.decodeRepeatedMessageField(value: &_storage._filmstripConfig) }()
        case 63: try { try decoder.decodeSingularBoolField(value: &_storage._showSigninButton) }()
        case 64: try { try decoder.decodeSingularMessageField(value: &_storage._startupTipsIntlURL) }()
        case 65: try { try decoder.decodeSingularMessageField(value: &_storage._proMeasureUpsellURL) }()
        case 66: try { try decoder.decodeSingularMessageField(value: &_storage._proPrintUpsellURL) }()
        case 67: try { try decoder.decodeSingularMessageField(value: &_storage._starDataProto) }()
        case 68: try { try decoder.decodeSingularMessageField(value: &_storage._feedbackURL) }()
        case 69: try { try decoder.decodeSingularMessageField(value: &_storage._oauth2LoginURL) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._model {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._authServerURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._disableAuthentication {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      if !_storage._mfeDomains.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mfeDomains, fieldNumber: 4)
      }
      try { if let v = _storage._mfeLangParam {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._adsURLPatterns {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._reverseGeocoderURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._reverseGeocoderProtocolVersion {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._skyDatabaseIsAvailable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._skyDatabaseURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._defaultWebPageIntlURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._numStartUpTips {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._startUpTipsURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._userGuideIntlURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._supportCenterIntlURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._businessListingIntlURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._supportAnswerIntlURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._supportTopicIntlURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._supportRequestIntlURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._earthIntlURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._addContentURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._sketchupNotInstalledURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._sketchupErrorURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._freeLicenseURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._proLicenseURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._hideUserData {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._useGeLogo {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._dioramaDescriptionURLBase {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._dioramaDefaultColor {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._clientOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._fetchingOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._timeMachineOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._csiOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      if !_storage._searchTab.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._searchTab, fieldNumber: 34)
      }
      if !_storage._cobrandInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cobrandInfo, fieldNumber: 35)
      }
      if !_storage._validDatabase.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._validDatabase, fieldNumber: 36)
      }
      if !_storage._configScript.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._configScript, fieldNumber: 37)
      }
      try { if let v = _storage._deauthServerURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      } }()
      try { if let v = _storage._swoopParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      } }()
      try { if let v = _storage._bbsServerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._dataErrorServerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      } }()
      if !_storage._planetaryDatabase.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._planetaryDatabase, fieldNumber: 42)
      }
      try { if let v = _storage._logServer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._autopiaOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._searchInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._elevationServiceBaseURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 46)
      } }()
      try { if let v = _storage._elevationProfileQueryDelay {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 47)
      } }()
      try { if let v = _storage._tutorialURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      } }()
      try { if let v = _storage._keyboardShortcutsURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      } }()
      try { if let v = _storage._releaseNotesURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      } }()
      try { if let v = _storage._numProStartUpTips {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 51)
      } }()
      try { if let v = _storage._proStartUpTipsURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      } }()
      try { if let v = _storage._dioramaBlacklistURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      } }()
      try { if let v = _storage._searchConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      } }()
      try { if let v = _storage._proUpgradeURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      } }()
      try { if let v = _storage._earthCommunityURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      } }()
      try { if let v = _storage._googleMapsURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      } }()
      try { if let v = _storage._sharingURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      } }()
      try { if let v = _storage._privacyPolicyURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
      } }()
      try { if let v = _storage._doGplusUserCheck {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 60)
      } }()
      try { if let v = _storage._rocktreeDataProto {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      } }()
      if !_storage._filmstripConfig.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._filmstripConfig, fieldNumber: 62)
      }
      try { if let v = _storage._showSigninButton {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 63)
      } }()
      try { if let v = _storage._startupTipsIntlURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
      } }()
      try { if let v = _storage._proMeasureUpsellURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
      } }()
      try { if let v = _storage._proPrintUpsellURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
      } }()
      try { if let v = _storage._starDataProto {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
      } }()
      try { if let v = _storage._feedbackURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
      } }()
      try { if let v = _storage._oauth2LoginURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 69)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_EndSnippetProto, rhs: Keyhole_Dbroot_EndSnippetProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._model != rhs_storage._model {return false}
        if _storage._authServerURL != rhs_storage._authServerURL {return false}
        if _storage._disableAuthentication != rhs_storage._disableAuthentication {return false}
        if _storage._mfeDomains != rhs_storage._mfeDomains {return false}
        if _storage._mfeLangParam != rhs_storage._mfeLangParam {return false}
        if _storage._adsURLPatterns != rhs_storage._adsURLPatterns {return false}
        if _storage._reverseGeocoderURL != rhs_storage._reverseGeocoderURL {return false}
        if _storage._reverseGeocoderProtocolVersion != rhs_storage._reverseGeocoderProtocolVersion {return false}
        if _storage._skyDatabaseIsAvailable != rhs_storage._skyDatabaseIsAvailable {return false}
        if _storage._skyDatabaseURL != rhs_storage._skyDatabaseURL {return false}
        if _storage._defaultWebPageIntlURL != rhs_storage._defaultWebPageIntlURL {return false}
        if _storage._numStartUpTips != rhs_storage._numStartUpTips {return false}
        if _storage._startUpTipsURL != rhs_storage._startUpTipsURL {return false}
        if _storage._numProStartUpTips != rhs_storage._numProStartUpTips {return false}
        if _storage._proStartUpTipsURL != rhs_storage._proStartUpTipsURL {return false}
        if _storage._startupTipsIntlURL != rhs_storage._startupTipsIntlURL {return false}
        if _storage._userGuideIntlURL != rhs_storage._userGuideIntlURL {return false}
        if _storage._supportCenterIntlURL != rhs_storage._supportCenterIntlURL {return false}
        if _storage._businessListingIntlURL != rhs_storage._businessListingIntlURL {return false}
        if _storage._supportAnswerIntlURL != rhs_storage._supportAnswerIntlURL {return false}
        if _storage._supportTopicIntlURL != rhs_storage._supportTopicIntlURL {return false}
        if _storage._supportRequestIntlURL != rhs_storage._supportRequestIntlURL {return false}
        if _storage._earthIntlURL != rhs_storage._earthIntlURL {return false}
        if _storage._addContentURL != rhs_storage._addContentURL {return false}
        if _storage._sketchupNotInstalledURL != rhs_storage._sketchupNotInstalledURL {return false}
        if _storage._sketchupErrorURL != rhs_storage._sketchupErrorURL {return false}
        if _storage._freeLicenseURL != rhs_storage._freeLicenseURL {return false}
        if _storage._proLicenseURL != rhs_storage._proLicenseURL {return false}
        if _storage._tutorialURL != rhs_storage._tutorialURL {return false}
        if _storage._keyboardShortcutsURL != rhs_storage._keyboardShortcutsURL {return false}
        if _storage._releaseNotesURL != rhs_storage._releaseNotesURL {return false}
        if _storage._hideUserData != rhs_storage._hideUserData {return false}
        if _storage._useGeLogo != rhs_storage._useGeLogo {return false}
        if _storage._dioramaDescriptionURLBase != rhs_storage._dioramaDescriptionURLBase {return false}
        if _storage._dioramaDefaultColor != rhs_storage._dioramaDefaultColor {return false}
        if _storage._dioramaBlacklistURL != rhs_storage._dioramaBlacklistURL {return false}
        if _storage._clientOptions != rhs_storage._clientOptions {return false}
        if _storage._fetchingOptions != rhs_storage._fetchingOptions {return false}
        if _storage._timeMachineOptions != rhs_storage._timeMachineOptions {return false}
        if _storage._csiOptions != rhs_storage._csiOptions {return false}
        if _storage._searchTab != rhs_storage._searchTab {return false}
        if _storage._cobrandInfo != rhs_storage._cobrandInfo {return false}
        if _storage._validDatabase != rhs_storage._validDatabase {return false}
        if _storage._configScript != rhs_storage._configScript {return false}
        if _storage._deauthServerURL != rhs_storage._deauthServerURL {return false}
        if _storage._swoopParameters != rhs_storage._swoopParameters {return false}
        if _storage._bbsServerInfo != rhs_storage._bbsServerInfo {return false}
        if _storage._dataErrorServerInfo != rhs_storage._dataErrorServerInfo {return false}
        if _storage._planetaryDatabase != rhs_storage._planetaryDatabase {return false}
        if _storage._logServer != rhs_storage._logServer {return false}
        if _storage._autopiaOptions != rhs_storage._autopiaOptions {return false}
        if _storage._searchConfig != rhs_storage._searchConfig {return false}
        if _storage._searchInfo != rhs_storage._searchInfo {return false}
        if _storage._elevationServiceBaseURL != rhs_storage._elevationServiceBaseURL {return false}
        if _storage._elevationProfileQueryDelay != rhs_storage._elevationProfileQueryDelay {return false}
        if _storage._proUpgradeURL != rhs_storage._proUpgradeURL {return false}
        if _storage._earthCommunityURL != rhs_storage._earthCommunityURL {return false}
        if _storage._googleMapsURL != rhs_storage._googleMapsURL {return false}
        if _storage._sharingURL != rhs_storage._sharingURL {return false}
        if _storage._privacyPolicyURL != rhs_storage._privacyPolicyURL {return false}
        if _storage._doGplusUserCheck != rhs_storage._doGplusUserCheck {return false}
        if _storage._rocktreeDataProto != rhs_storage._rocktreeDataProto {return false}
        if _storage._filmstripConfig != rhs_storage._filmstripConfig {return false}
        if _storage._showSigninButton != rhs_storage._showSigninButton {return false}
        if _storage._proMeasureUpsellURL != rhs_storage._proMeasureUpsellURL {return false}
        if _storage._proPrintUpsellURL != rhs_storage._proPrintUpsellURL {return false}
        if _storage._starDataProto != rhs_storage._starDataProto {return false}
        if _storage._feedbackURL != rhs_storage._feedbackURL {return false}
        if _storage._oauth2LoginURL != rhs_storage._oauth2LoginURL {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_EndSnippetProto.SearchConfigProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_EndSnippetProto.protoMessageName + ".SearchConfigProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "search_server"),
    2: .standard(proto: "onebox_service"),
    3: .standard(proto: "kml_search_url"),
    4: .standard(proto: "kml_render_url"),
    6: .standard(proto: "search_history_url"),
    5: .standard(proto: "error_page_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.searchServer) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.oneboxService) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._kmlSearchURL) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._kmlRenderURL) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._errorPageURL) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._searchHistoryURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.searchServer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searchServer, fieldNumber: 1)
    }
    if !self.oneboxService.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oneboxService, fieldNumber: 2)
    }
    try { if let v = self._kmlSearchURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._kmlRenderURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._errorPageURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._searchHistoryURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto, rhs: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto) -> Bool {
    if lhs.searchServer != rhs.searchServer {return false}
    if lhs.oneboxService != rhs.oneboxService {return false}
    if lhs._kmlSearchURL != rhs._kmlSearchURL {return false}
    if lhs._kmlRenderURL != rhs._kmlRenderURL {return false}
    if lhs._searchHistoryURL != rhs._searchHistoryURL {return false}
    if lhs._errorPageURL != rhs._errorPageURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.protoMessageName + ".SearchServer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
    3: .same(proto: "type"),
    4: .standard(proto: "html_transform_url"),
    5: .standard(proto: "kml_transform_url"),
    6: .standard(proto: "supplemental_ui"),
    9: .same(proto: "suggestion"),
    7: .same(proto: "searchlet"),
    8: .same(proto: "requirements"),
    10: .standard(proto: "suggest_server"),
  ]

  fileprivate class _StorageClass {
    var _name: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _url: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _type: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.ResultType? = nil
    var _htmlTransformURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _kmlTransformURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _supplementalUi: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.SupplementalUi? = nil
    var _suggestion: [Keyhole_Dbroot_StringIdOrValueProto] = []
    var _searchlet: [Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.SearchletProto] = []
    var _requirements: Keyhole_Dbroot_RequirementProto? = nil
    var _suggestServer: Keyhole_Dbroot_StringIdOrValueProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _url = source._url
      _type = source._type
      _htmlTransformURL = source._htmlTransformURL
      _kmlTransformURL = source._kmlTransformURL
      _supplementalUi = source._supplementalUi
      _suggestion = source._suggestion
      _searchlet = source._searchlet
      _requirements = source._requirements
      _suggestServer = source._suggestServer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._url) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._htmlTransformURL) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._kmlTransformURL) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._supplementalUi) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._searchlet) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._requirements) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._suggestion) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._suggestServer) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._url {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._htmlTransformURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._kmlTransformURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._supplementalUi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._searchlet.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._searchlet, fieldNumber: 7)
      }
      try { if let v = _storage._requirements {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._suggestion.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._suggestion, fieldNumber: 9)
      }
      try { if let v = _storage._suggestServer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer, rhs: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._htmlTransformURL != rhs_storage._htmlTransformURL {return false}
        if _storage._kmlTransformURL != rhs_storage._kmlTransformURL {return false}
        if _storage._supplementalUi != rhs_storage._supplementalUi {return false}
        if _storage._suggestion != rhs_storage._suggestion {return false}
        if _storage._searchlet != rhs_storage._searchlet {return false}
        if _storage._requirements != rhs_storage._requirements {return false}
        if _storage._suggestServer != rhs_storage._suggestServer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.ResultType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_TYPE_KML"),
    1: .same(proto: "RESULT_TYPE_XML"),
  ]
}

extension Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.SupplementalUi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.protoMessageName + ".SupplementalUi"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "label"),
    3: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._label) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.SupplementalUi, rhs: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.SupplementalUi) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._label != rhs._label {return false}
    if lhs._height != rhs._height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.SearchletProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.protoMessageName + ".SearchletProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "name"),
    3: .same(proto: "requirements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._requirements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._requirements {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.SearchletProto, rhs: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.SearchServer.SearchletProto) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._name != rhs._name {return false}
    if lhs._requirements != rhs._requirements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.OneboxServiceProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.protoMessageName + ".OneboxServiceProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_url"),
    2: .same(proto: "requirements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._serviceURL) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._requirements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serviceURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._requirements {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.OneboxServiceProto, rhs: Keyhole_Dbroot_EndSnippetProto.SearchConfigProto.OneboxServiceProto) -> Bool {
    if lhs._serviceURL != rhs._serviceURL {return false}
    if lhs._requirements != rhs._requirements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_EndSnippetProto.SearchInfoProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_EndSnippetProto.protoMessageName + ".SearchInfoProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_url"),
    2: .standard(proto: "geocode_param"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._defaultURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._geocodeParam) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._defaultURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._geocodeParam {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_EndSnippetProto.SearchInfoProto, rhs: Keyhole_Dbroot_EndSnippetProto.SearchInfoProto) -> Bool {
    if lhs._defaultURL != rhs._defaultURL {return false}
    if lhs._geocodeParam != rhs._geocodeParam {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_EndSnippetProto.RockTreeDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_EndSnippetProto.protoMessageName + ".RockTreeDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_EndSnippetProto.RockTreeDataProto, rhs: Keyhole_Dbroot_EndSnippetProto.RockTreeDataProto) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_EndSnippetProto.FilmstripConfigProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_EndSnippetProto.protoMessageName + ".FilmstripConfigProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requirements"),
    2: .standard(proto: "alleycat_url_template"),
    9: .standard(proto: "fallback_alleycat_url_template"),
    3: .standard(proto: "metadata_url_template"),
    4: .standard(proto: "thumbnail_url_template"),
    5: .standard(proto: "kml_url_template"),
    6: .standard(proto: "featured_tours_url"),
    7: .standard(proto: "enable_viewport_fallback"),
    8: .standard(proto: "viewport_fallback_distance"),
    10: .standard(proto: "imagery_type"),
  ]

  fileprivate class _StorageClass {
    var _requirements: Keyhole_Dbroot_RequirementProto? = nil
    var _alleycatURLTemplate: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _fallbackAlleycatURLTemplate: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _metadataURLTemplate: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _thumbnailURLTemplate: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _kmlURLTemplate: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _featuredToursURL: Keyhole_Dbroot_StringIdOrValueProto? = nil
    var _enableViewportFallback: Bool? = nil
    var _viewportFallbackDistance: UInt32? = nil
    var _imageryType: [Keyhole_Dbroot_EndSnippetProto.FilmstripConfigProto.AlleycatImageryTypeProto] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _requirements = source._requirements
      _alleycatURLTemplate = source._alleycatURLTemplate
      _fallbackAlleycatURLTemplate = source._fallbackAlleycatURLTemplate
      _metadataURLTemplate = source._metadataURLTemplate
      _thumbnailURLTemplate = source._thumbnailURLTemplate
      _kmlURLTemplate = source._kmlURLTemplate
      _featuredToursURL = source._featuredToursURL
      _enableViewportFallback = source._enableViewportFallback
      _viewportFallbackDistance = source._viewportFallbackDistance
      _imageryType = source._imageryType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._requirements) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._alleycatURLTemplate) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._metadataURLTemplate) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnailURLTemplate) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._kmlURLTemplate) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._featuredToursURL) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._enableViewportFallback) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._viewportFallbackDistance) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._fallbackAlleycatURLTemplate) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._imageryType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._requirements {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._alleycatURLTemplate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._metadataURLTemplate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._thumbnailURLTemplate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._kmlURLTemplate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._featuredToursURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._enableViewportFallback {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._viewportFallbackDistance {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._fallbackAlleycatURLTemplate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._imageryType.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._imageryType, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_EndSnippetProto.FilmstripConfigProto, rhs: Keyhole_Dbroot_EndSnippetProto.FilmstripConfigProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._requirements != rhs_storage._requirements {return false}
        if _storage._alleycatURLTemplate != rhs_storage._alleycatURLTemplate {return false}
        if _storage._fallbackAlleycatURLTemplate != rhs_storage._fallbackAlleycatURLTemplate {return false}
        if _storage._metadataURLTemplate != rhs_storage._metadataURLTemplate {return false}
        if _storage._thumbnailURLTemplate != rhs_storage._thumbnailURLTemplate {return false}
        if _storage._kmlURLTemplate != rhs_storage._kmlURLTemplate {return false}
        if _storage._featuredToursURL != rhs_storage._featuredToursURL {return false}
        if _storage._enableViewportFallback != rhs_storage._enableViewportFallback {return false}
        if _storage._viewportFallbackDistance != rhs_storage._viewportFallbackDistance {return false}
        if _storage._imageryType != rhs_storage._imageryType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_EndSnippetProto.FilmstripConfigProto.AlleycatImageryTypeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_EndSnippetProto.FilmstripConfigProto.protoMessageName + ".AlleycatImageryTypeProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "imagery_type_id"),
    2: .standard(proto: "imagery_type_label"),
    3: .standard(proto: "metadata_url_template"),
    4: .standard(proto: "thumbnail_url_template"),
    5: .standard(proto: "kml_url_template"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._imageryTypeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._imageryTypeLabel) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadataURLTemplate) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._thumbnailURLTemplate) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._kmlURLTemplate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._imageryTypeID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._imageryTypeLabel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._metadataURLTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._thumbnailURLTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._kmlURLTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_EndSnippetProto.FilmstripConfigProto.AlleycatImageryTypeProto, rhs: Keyhole_Dbroot_EndSnippetProto.FilmstripConfigProto.AlleycatImageryTypeProto) -> Bool {
    if lhs._imageryTypeID != rhs._imageryTypeID {return false}
    if lhs._imageryTypeLabel != rhs._imageryTypeLabel {return false}
    if lhs._metadataURLTemplate != rhs._metadataURLTemplate {return false}
    if lhs._thumbnailURLTemplate != rhs._thumbnailURLTemplate {return false}
    if lhs._kmlURLTemplate != rhs._kmlURLTemplate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_EndSnippetProto.StarDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_Dbroot_EndSnippetProto.protoMessageName + ".StarDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_EndSnippetProto.StarDataProto, rhs: Keyhole_Dbroot_EndSnippetProto.StarDataProto) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_DbRootRefProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DbRootRefProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "url"),
    1: .standard(proto: "is_critical"),
    3: .same(proto: "requirements"),
  ]

  public var isInitialized: Bool {
    if self._url == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isCritical) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._requirements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isCritical {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._requirements {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_DbRootRefProto, rhs: Keyhole_Dbroot_DbRootRefProto) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._isCritical != rhs._isCritical {return false}
    if lhs._requirements != rhs._requirements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_DatabaseVersionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseVersionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quadtree_version"),
  ]

  public var isInitialized: Bool {
    if self._quadtreeVersion == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._quadtreeVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._quadtreeVersion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_DatabaseVersionProto, rhs: Keyhole_Dbroot_DatabaseVersionProto) -> Bool {
    if lhs._quadtreeVersion != rhs._quadtreeVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_DbRootProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DbRootProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    15: .standard(proto: "database_name"),
    1: .standard(proto: "imagery_present"),
    14: .standard(proto: "proto_imagery"),
    2: .standard(proto: "terrain_present"),
    3: .standard(proto: "provider_info"),
    4: .standard(proto: "nested_feature"),
    5: .standard(proto: "style_attribute"),
    6: .standard(proto: "style_map"),
    7: .standard(proto: "end_snippet"),
    8: .standard(proto: "translation_entry"),
    9: .same(proto: "language"),
    10: .same(proto: "version"),
    11: .standard(proto: "dbroot_reference"),
    13: .standard(proto: "database_version"),
    16: .standard(proto: "refresh_timeout"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.providerInfo) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.nestedFeature) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.styleAttribute) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.styleMap) {return false}
    if let v = self._endSnippet, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.translationEntry) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.dbrootReference) {return false}
    if let v = self._databaseVersion, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._imageryPresent) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._terrainPresent) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.providerInfo) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.nestedFeature) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.styleAttribute) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.styleMap) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._endSnippet) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.translationEntry) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._language) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._version) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.dbrootReference) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._databaseVersion) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self._protoImagery) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._databaseName) }()
      case 16: try { try decoder.decodeSingularInt32Field(value: &self._refreshTimeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._imageryPresent {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._terrainPresent {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.providerInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.providerInfo, fieldNumber: 3)
    }
    if !self.nestedFeature.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nestedFeature, fieldNumber: 4)
    }
    if !self.styleAttribute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.styleAttribute, fieldNumber: 5)
    }
    if !self.styleMap.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.styleMap, fieldNumber: 6)
    }
    try { if let v = self._endSnippet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.translationEntry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.translationEntry, fieldNumber: 8)
    }
    try { if let v = self._language {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    } }()
    if !self.dbrootReference.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dbrootReference, fieldNumber: 11)
    }
    try { if let v = self._databaseVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._protoImagery {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._databaseName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try { if let v = self._refreshTimeout {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 16)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_DbRootProto, rhs: Keyhole_Dbroot_DbRootProto) -> Bool {
    if lhs._databaseName != rhs._databaseName {return false}
    if lhs._imageryPresent != rhs._imageryPresent {return false}
    if lhs._protoImagery != rhs._protoImagery {return false}
    if lhs._terrainPresent != rhs._terrainPresent {return false}
    if lhs.providerInfo != rhs.providerInfo {return false}
    if lhs.nestedFeature != rhs.nestedFeature {return false}
    if lhs.styleAttribute != rhs.styleAttribute {return false}
    if lhs.styleMap != rhs.styleMap {return false}
    if lhs._endSnippet != rhs._endSnippet {return false}
    if lhs.translationEntry != rhs.translationEntry {return false}
    if lhs._language != rhs._language {return false}
    if lhs._version != rhs._version {return false}
    if lhs.dbrootReference != rhs.dbrootReference {return false}
    if lhs._databaseVersion != rhs._databaseVersion {return false}
    if lhs._refreshTimeout != rhs._refreshTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_EncryptedDbRootProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptedDbRootProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encryption_type"),
    2: .standard(proto: "encryption_data"),
    3: .standard(proto: "dbroot_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._encryptionType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._encryptionData) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._dbrootData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._encryptionType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._encryptionData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dbrootData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_Dbroot_EncryptedDbRootProto, rhs: Keyhole_Dbroot_EncryptedDbRootProto) -> Bool {
    if lhs._encryptionType != rhs._encryptionType {return false}
    if lhs._encryptionData != rhs._encryptionData {return false}
    if lhs._dbrootData != rhs._dbrootData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_Dbroot_EncryptedDbRootProto.EncryptionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENCRYPTION_XOR"),
  ]
}
