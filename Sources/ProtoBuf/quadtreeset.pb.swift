// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: quadtreeset.protodevel
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
// Protocol buffers for next-generation quadtree packets.
//
// We divide the globe up into a quadtree.  Each node of the quadtree contains
// information about what layers are available at that node.  The entire
// quadtree is divided up into QuadtreePacket's, each of which contains an
// n-level subtree of the full quadtree.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Channels come from Fusion and use Fusion's numbering scheme.
struct Keyhole_QuadtreeChannel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Int32 {
    get {return _type ?? 0}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var channelEpoch: Int32 {
    get {return _channelEpoch ?? 0}
    set {_channelEpoch = newValue}
  }
  /// Returns true if `channelEpoch` has been explicitly set.
  var hasChannelEpoch: Bool {return self._channelEpoch != nil}
  /// Clears the value of `channelEpoch`. Subsequent reads from it will return its default value.
  mutating func clearChannelEpoch() {self._channelEpoch = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: Int32? = nil
  fileprivate var _channelEpoch: Int32? = nil
}

/// "Timed" tile for a specific day:
/// Each tile's tile within the day and version are given in this message.
struct Keyhole_QuadtreeImageryTimedTile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Milliseconds since midnight, have to be "required" to make legacy client
  /// work.
  var milliseconds: Int32 {
    get {return _milliseconds ?? 0}
    set {_milliseconds = newValue}
  }
  /// Returns true if `milliseconds` has been explicitly set.
  var hasMilliseconds: Bool {return self._milliseconds != nil}
  /// Clears the value of `milliseconds`. Subsequent reads from it will return its default value.
  mutating func clearMilliseconds() {self._milliseconds = nil}

  /// The version of the timed tile, exists if different from "dated_tile_epoch"
  /// in "QuadtreeImageryDatedTile", have to be "required" to make legacy client
  /// work.
  var timedTileEpoch: Int32 {
    get {return _timedTileEpoch ?? 0}
    set {_timedTileEpoch = newValue}
  }
  /// Returns true if `timedTileEpoch` has been explicitly set.
  var hasTimedTileEpoch: Bool {return self._timedTileEpoch != nil}
  /// Clears the value of `timedTileEpoch`. Subsequent reads from it will return its default value.
  mutating func clearTimedTileEpoch() {self._timedTileEpoch = nil}

  /// The provider of the timed tile, exists if different from "provider" in
  /// "QuadtreeImageryDatedTile".
  var provider: Int32 {
    get {return _provider ?? 0}
    set {_provider = newValue}
  }
  /// Returns true if `provider` has been explicitly set.
  var hasProvider: Bool {return self._provider != nil}
  /// Clears the value of `provider`. Subsequent reads from it will return its default value.
  mutating func clearProvider() {self._provider = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _milliseconds: Int32? = nil
  fileprivate var _timedTileEpoch: Int32? = nil
  fileprivate var _provider: Int32? = nil
}

/// Layer-specific info for Time Machine dates.
/// One entry for each dated tile available.
/// Date in JpegCommentDate::YearMonthDayKey format.
/// dated_tile_epoch is the version of the Time Machine tile.
/// If a tile can be shared with keyhole-hires, its date is given in
/// shared_tile_date.
/// The timed_tiles field contains additional tiles with finer time resolution
/// than one day. The timed_tiles will be sorted in ascending order.
/// Note that a "one day" tile is still required for older
/// clients which won't see the timed_tiles field.
struct Keyhole_QuadtreeImageryDatedTile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var date: Int32 {
    get {return _date ?? 0}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var datedTileEpoch: Int32 {
    get {return _datedTileEpoch ?? 0}
    set {_datedTileEpoch = newValue}
  }
  /// Returns true if `datedTileEpoch` has been explicitly set.
  var hasDatedTileEpoch: Bool {return self._datedTileEpoch != nil}
  /// Clears the value of `datedTileEpoch`. Subsequent reads from it will return its default value.
  mutating func clearDatedTileEpoch() {self._datedTileEpoch = nil}

  var provider: Int32 {
    get {return _provider ?? 0}
    set {_provider = newValue}
  }
  /// Returns true if `provider` has been explicitly set.
  var hasProvider: Bool {return self._provider != nil}
  /// Clears the value of `provider`. Subsequent reads from it will return its default value.
  mutating func clearProvider() {self._provider = nil}

  var timedTiles: [Keyhole_QuadtreeImageryTimedTile] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _date: Int32? = nil
  fileprivate var _datedTileEpoch: Int32? = nil
  fileprivate var _provider: Int32? = nil
}

struct Keyhole_QuadtreeImageryDates {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var datedTile: [Keyhole_QuadtreeImageryDatedTile] = []

  /// date of tile shared from keyhole
  var sharedTileDate: Int32 {
    get {return _sharedTileDate ?? 0}
    set {_sharedTileDate = newValue}
  }
  /// Returns true if `sharedTileDate` has been explicitly set.
  var hasSharedTileDate: Bool {return self._sharedTileDate != nil}
  /// Clears the value of `sharedTileDate`. Subsequent reads from it will return its default value.
  mutating func clearSharedTileDate() {self._sharedTileDate = nil}

  /// Dates of tiles from coarser levels with assets that are visible in this
  /// tile. Date is in JpegCommentDate::YearMonthDayKey format as an int.
  /// These will be sorted in ascending order.
  /// The dates here do not intersect the dates of tiles in dated_tile, but are
  /// complement to them. "coarse_tile_dates" belong to tiles from upper levels
  /// with coarser resolution and are not visible at current level. They exist
  /// here to make user aware of different layers at upper level.
  var coarseTileDates: [Int32] = []

  /// Time (milliseconds from midnight) of tile shared from keyhole.
  var sharedTileMilliseconds: Int32 {
    get {return _sharedTileMilliseconds ?? 0}
    set {_sharedTileMilliseconds = newValue}
  }
  /// Returns true if `sharedTileMilliseconds` has been explicitly set.
  var hasSharedTileMilliseconds: Bool {return self._sharedTileMilliseconds != nil}
  /// Clears the value of `sharedTileMilliseconds`. Subsequent reads from it will return its default value.
  mutating func clearSharedTileMilliseconds() {self._sharedTileMilliseconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sharedTileDate: Int32? = nil
  fileprivate var _sharedTileMilliseconds: Int32? = nil
}

struct Keyhole_QuadtreeLayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// type of this layer
  var type: Keyhole_QuadtreeLayer.LayerType {
    get {return _type ?? .imagery}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// epoch of this layer
  var layerEpoch: Int32 {
    get {return _layerEpoch ?? 0}
    set {_layerEpoch = newValue}
  }
  /// Returns true if `layerEpoch` has been explicitly set.
  var hasLayerEpoch: Bool {return self._layerEpoch != nil}
  /// Clears the value of `layerEpoch`. Subsequent reads from it will return its default value.
  mutating func clearLayerEpoch() {self._layerEpoch = nil}

  /// provider id for this layer
  var provider: Int32 {
    get {return _provider ?? 0}
    set {_provider = newValue}
  }
  /// Returns true if `provider` has been explicitly set.
  var hasProvider: Bool {return self._provider != nil}
  /// Clears the value of `provider`. Subsequent reads from it will return its default value.
  mutating func clearProvider() {self._provider = nil}

  /// If there is additional information for a layer type, add it here:
  var datesLayer: Keyhole_QuadtreeImageryDates {
    get {return _datesLayer ?? Keyhole_QuadtreeImageryDates()}
    set {_datesLayer = newValue}
  }
  /// Returns true if `datesLayer` has been explicitly set.
  var hasDatesLayer: Bool {return self._datesLayer != nil}
  /// Clears the value of `datesLayer`. Subsequent reads from it will return its default value.
  mutating func clearDatesLayer() {self._datesLayer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum LayerType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case imagery // = 0
    case terrain // = 1
    case vector // = 2
    case imageryHistory // = 3

    init() {
      self = .imagery
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .imagery
      case 1: self = .terrain
      case 2: self = .vector
      case 3: self = .imageryHistory
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .imagery: return 0
      case .terrain: return 1
      case .vector: return 2
      case .imageryHistory: return 3
      }
    }

  }

  init() {}

  fileprivate var _type: Keyhole_QuadtreeLayer.LayerType? = nil
  fileprivate var _layerEpoch: Int32? = nil
  fileprivate var _provider: Int32? = nil
  fileprivate var _datesLayer: Keyhole_QuadtreeImageryDates? = nil
}

#if swift(>=4.2)

extension Keyhole_QuadtreeLayer.LayerType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Keyhole_QuadtreeNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var flags: Int32 {
    get {return _flags ?? 0}
    set {_flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return self._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {self._flags = nil}

  /// The epoch when this node was generated.
  /// Currently, all the nodes in a packet are generated at the same time,
  /// so each node has the same version. This may change in the future if
  /// we only generate the changed nodes. The client uses this to keep its
  /// node cache fresh.
  var cacheNodeEpoch: Int32 {
    get {return _cacheNodeEpoch ?? 0}
    set {_cacheNodeEpoch = newValue}
  }
  /// Returns true if `cacheNodeEpoch` has been explicitly set.
  var hasCacheNodeEpoch: Bool {return self._cacheNodeEpoch != nil}
  /// Clears the value of `cacheNodeEpoch`. Subsequent reads from it will return its default value.
  mutating func clearCacheNodeEpoch() {self._cacheNodeEpoch = nil}

  /// The layer data for this node.
  /// Layers: image, vector, terrain, etc.
  var layer: [Keyhole_QuadtreeLayer] = []

  /// The channel info for this node.
  /// Channels are components of the vector layer and come
  /// from the Fusion pipeline.
  var channel: [Keyhole_QuadtreeChannel] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A bitfield of flags for this node.
  /// 0-3: presence bits for each interior child node.
  /// 4: for leaf nodes, this indicates other quadtree sets are below this node
  /// 5: vector data present in this node.
  /// 6: imagery data present in this node.
  /// 7: terrain data present in this node.
  enum NodeFlags: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// interior node indication of child presence
    case childCount // = 4

    /// there's data below leaf nodes
    static let cacheBit = childCount

    /// there's vector data in this node
    case drawableBit // = 5

    /// there's image data in this node
    case imageBit // = 6

    /// there's terrain data in this node
    case terrainBit // = 7

    init() {
      self = .childCount
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 4: self = .childCount
      case 5: self = .drawableBit
      case 6: self = .imageBit
      case 7: self = .terrainBit
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .childCount: return 4
      case .drawableBit: return 5
      case .imageBit: return 6
      case .terrainBit: return 7
      }
    }

  }

  init() {}

  fileprivate var _flags: Int32? = nil
  fileprivate var _cacheNodeEpoch: Int32? = nil
}

#if swift(>=4.2)

extension Keyhole_QuadtreeNode.NodeFlags: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// A full quadtree packet.  This contains a subtree of the full global
/// quadtree.
struct Keyhole_QuadtreePacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Epoch of when this quadtree packet was generated.
  var packetEpoch: Int32 {
    get {return _packetEpoch ?? 0}
    set {_packetEpoch = newValue}
  }
  /// Returns true if `packetEpoch` has been explicitly set.
  var hasPacketEpoch: Bool {return self._packetEpoch != nil}
  /// Clears the value of `packetEpoch`. Subsequent reads from it will return its default value.
  mutating func clearPacketEpoch() {self._packetEpoch = nil}

  var sparseQuadtreeNode: [Keyhole_QuadtreePacket.SparseQuadtreeNode] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// All the quadtree nodes in this packet, with subindex indices.
  struct SparseQuadtreeNode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Index of this node within the quadtree packet.  The nodes within
    /// a quadtree packet are numbered in subindex order and are sparse.
    /// Note: the nodes are not currently guaranteed to be sorted
    /// in any particular order.
    var index: Int32 {
      get {return _index ?? 0}
      set {_index = newValue}
    }
    /// Returns true if `index` has been explicitly set.
    var hasIndex: Bool {return self._index != nil}
    /// Clears the value of `index`. Subsequent reads from it will return its default value.
    mutating func clearIndex() {self._index = nil}

    /// the node itself
    var node: Keyhole_QuadtreeNode {
      get {return _node ?? Keyhole_QuadtreeNode()}
      set {_node = newValue}
    }
    /// Returns true if `node` has been explicitly set.
    var hasNode: Bool {return self._node != nil}
    /// Clears the value of `node`. Subsequent reads from it will return its default value.
    mutating func clearNode() {self._node = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _index: Int32? = nil
    fileprivate var _node: Keyhole_QuadtreeNode? = nil
  }

  init() {}

  fileprivate var _packetEpoch: Int32? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Keyhole_QuadtreeChannel: @unchecked Sendable {}
extension Keyhole_QuadtreeImageryTimedTile: @unchecked Sendable {}
extension Keyhole_QuadtreeImageryDatedTile: @unchecked Sendable {}
extension Keyhole_QuadtreeImageryDates: @unchecked Sendable {}
extension Keyhole_QuadtreeLayer: @unchecked Sendable {}
extension Keyhole_QuadtreeLayer.LayerType: @unchecked Sendable {}
extension Keyhole_QuadtreeNode: @unchecked Sendable {}
extension Keyhole_QuadtreeNode.NodeFlags: @unchecked Sendable {}
extension Keyhole_QuadtreePacket: @unchecked Sendable {}
extension Keyhole_QuadtreePacket.SparseQuadtreeNode: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "keyhole"

extension Keyhole_QuadtreeChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuadtreeChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "channel_epoch"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._channelEpoch == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._channelEpoch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._channelEpoch {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_QuadtreeChannel, rhs: Keyhole_QuadtreeChannel) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._channelEpoch != rhs._channelEpoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_QuadtreeImageryTimedTile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuadtreeImageryTimedTile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "milliseconds"),
    2: .standard(proto: "timed_tile_epoch"),
    3: .same(proto: "provider"),
  ]

  public var isInitialized: Bool {
    if self._milliseconds == nil {return false}
    if self._timedTileEpoch == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._milliseconds) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._timedTileEpoch) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._provider) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._milliseconds {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timedTileEpoch {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._provider {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_QuadtreeImageryTimedTile, rhs: Keyhole_QuadtreeImageryTimedTile) -> Bool {
    if lhs._milliseconds != rhs._milliseconds {return false}
    if lhs._timedTileEpoch != rhs._timedTileEpoch {return false}
    if lhs._provider != rhs._provider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_QuadtreeImageryDatedTile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuadtreeImageryDatedTile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .standard(proto: "dated_tile_epoch"),
    3: .same(proto: "provider"),
    4: .standard(proto: "timed_tiles"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._datedTileEpoch == nil {return false}
    if self._provider == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.timedTiles) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._date) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._datedTileEpoch) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._provider) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.timedTiles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._datedTileEpoch {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._provider {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.timedTiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timedTiles, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_QuadtreeImageryDatedTile, rhs: Keyhole_QuadtreeImageryDatedTile) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._datedTileEpoch != rhs._datedTileEpoch {return false}
    if lhs._provider != rhs._provider {return false}
    if lhs.timedTiles != rhs.timedTiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_QuadtreeImageryDates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuadtreeImageryDates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dated_tile"),
    2: .standard(proto: "shared_tile_date"),
    3: .standard(proto: "coarse_tile_dates"),
    4: .standard(proto: "shared_tile_milliseconds"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.datedTile) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.datedTile) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._sharedTileDate) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.coarseTileDates) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._sharedTileMilliseconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.datedTile.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datedTile, fieldNumber: 1)
    }
    try { if let v = self._sharedTileDate {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.coarseTileDates.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.coarseTileDates, fieldNumber: 3)
    }
    try { if let v = self._sharedTileMilliseconds {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_QuadtreeImageryDates, rhs: Keyhole_QuadtreeImageryDates) -> Bool {
    if lhs.datedTile != rhs.datedTile {return false}
    if lhs._sharedTileDate != rhs._sharedTileDate {return false}
    if lhs.coarseTileDates != rhs.coarseTileDates {return false}
    if lhs._sharedTileMilliseconds != rhs._sharedTileMilliseconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_QuadtreeLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuadtreeLayer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "layer_epoch"),
    3: .same(proto: "provider"),
    4: .standard(proto: "dates_layer"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._layerEpoch == nil {return false}
    if let v = self._datesLayer, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._layerEpoch) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._provider) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._datesLayer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._layerEpoch {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._provider {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._datesLayer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_QuadtreeLayer, rhs: Keyhole_QuadtreeLayer) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._layerEpoch != rhs._layerEpoch {return false}
    if lhs._provider != rhs._provider {return false}
    if lhs._datesLayer != rhs._datesLayer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_QuadtreeLayer.LayerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LAYER_TYPE_IMAGERY"),
    1: .same(proto: "LAYER_TYPE_TERRAIN"),
    2: .same(proto: "LAYER_TYPE_VECTOR"),
    3: .same(proto: "LAYER_TYPE_IMAGERY_HISTORY"),
  ]
}

extension Keyhole_QuadtreeNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuadtreeNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flags"),
    2: .standard(proto: "cache_node_epoch"),
    3: .same(proto: "layer"),
    4: .same(proto: "channel"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.layer) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.channel) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._flags) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._cacheNodeEpoch) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.layer) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._flags {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cacheNodeEpoch {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.layer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layer, fieldNumber: 3)
    }
    if !self.channel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channel, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_QuadtreeNode, rhs: Keyhole_QuadtreeNode) -> Bool {
    if lhs._flags != rhs._flags {return false}
    if lhs._cacheNodeEpoch != rhs._cacheNodeEpoch {return false}
    if lhs.layer != rhs.layer {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_QuadtreeNode.NodeFlags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .aliased(proto: "NODE_FLAGS_CHILD_COUNT", aliases: ["NODE_FLAGS_CACHE_BIT"]),
    5: .same(proto: "NODE_FLAGS_DRAWABLE_BIT"),
    6: .same(proto: "NODE_FLAGS_IMAGE_BIT"),
    7: .same(proto: "NODE_FLAGS_TERRAIN_BIT"),
  ]
}

extension Keyhole_QuadtreePacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuadtreePacket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_epoch"),
    2: .unique(proto: "SparseQuadtreeNode", json: "sparsequadtreenode"),
  ]

  public var isInitialized: Bool {
    if self._packetEpoch == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.sparseQuadtreeNode) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._packetEpoch) }()
      case 2: try { try decoder.decodeRepeatedGroupField(value: &self.sparseQuadtreeNode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._packetEpoch {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.sparseQuadtreeNode.isEmpty {
      try visitor.visitRepeatedGroupField(value: self.sparseQuadtreeNode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_QuadtreePacket, rhs: Keyhole_QuadtreePacket) -> Bool {
    if lhs._packetEpoch != rhs._packetEpoch {return false}
    if lhs.sparseQuadtreeNode != rhs.sparseQuadtreeNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keyhole_QuadtreePacket.SparseQuadtreeNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keyhole_QuadtreePacket.protoMessageName + ".SparseQuadtreeNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "index"),
    4: .same(proto: "Node"),
  ]

  public var isInitialized: Bool {
    if self._index == nil {return false}
    if self._node == nil {return false}
    if let v = self._node, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._index) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keyhole_QuadtreePacket.SparseQuadtreeNode, rhs: Keyhole_QuadtreePacket.SparseQuadtreeNode) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._node != rhs._node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
